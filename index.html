<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Backgammon – Another Product Invented</title>
  <style>
    body {
      background: #eee;
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
    /* Logo */
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
    /* Overlays (Menus, Instructions, etc.) */
    .overlayScreen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255,255,255,0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      text-align: center;
    }
    .overlayScreen h1, .overlayScreen h2, .overlayScreen p {
      margin: 10px;
    }
    .overlayScreen button {
      font-size: 20px;
      padding: 10px 20px;
      margin: 10px;
      cursor: pointer;
    }
    /* Main Game Container */
    #gameContainer {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: flex-start;
      padding: 20px;
    }
    #barContainer {
      width: 150px;
      text-align: center;
    }
    #boardContainer {
      position: relative;
      width: 720px;
      height: 800px;
      background: #f5f5f5;
      margin: 0 20px;
    }
    #diceContainer {
      width: 250px;
      text-align: center;
    }
    canvas {
      background: #fff;
      border: 2px solid #000;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <!-- Logo -->
  <img id="logo" src="logo.png" alt="Another Product Invented Logo">
  
  <!-- Overlays -->
  <div id="menuScreen" class="overlayScreen" style="display: flex;">
    <h1>Backgammon</h1>
    <button id="newGameBtn">New Game</button>
    <button id="instructionsBtn">Instructions</button>
  </div>
  
  <div id="colorScreen" class="overlayScreen">
    <h2>Choose Your Color</h2>
    <button id="whiteSideBtn">White [W]</button>
    <button id="blackSideBtn">Black [B]</button>
    <p>You can press W or B on your keyboard.</p>
  </div>
  
  <div id="difficultyScreen" class="overlayScreen">
    <h2>Select Difficulty</h2>
    <button id="easyBtn">Easy [E]</button>
    <button id="mediumBtn">Medium [M]</button>
    <button id="hardBtn">Hard [H]</button>
    <p>You can press E, M, or H on your keyboard.</p>
  </div>
  
  <div id="instructionsScreen" class="overlayScreen">
    <h2>How to Play</h2>
    <p>
      <strong>Rolling the Dice</strong> – Each player rolls two dice (animated for effect) and moves their checkers based on the numbers rolled.<br>
      <strong>Moving Checkers</strong> – White moves from point 24 down to 1 (by subtracting the die) and Black moves from point 1 up to 24 (by adding the die).<br>
      <strong>Landing on a Point</strong> – You may land on an open point or one occupied by your own checkers. Landing on a single opponent checker (a blot) sends it to the bar.<br>
      <strong>Re-entering from the Bar</strong> – If you have checkers on the bar, you must re‑enter them (White re‑enters into points 24–19; Black into points 1–6).<br>
      <strong>Bearing Off</strong> – You can bear off only when all your checkers are in your home board (White: points 1–6; Black: points 19–24).<br>
      <strong>Winning</strong> – The first player to bear off all their checkers wins.<br>
      Press [M] to return to the main menu.
    </p>
  </div>
  
  <div id="gameOverScreen" class="overlayScreen">
    <h2 id="gameOverText"></h2>
    <button id="gameOverNewGameBtn">New Game</button>
    <p>Press [M] to return to the main menu.</p>
  </div>
  
  <!-- Main Game Container -->
  <div id="gameContainer">
    <!-- Bar Column -->
    <div id="barContainer">
      <h3>Bar</h3>
      <canvas id="barCanvas" width="150" height="200"></canvas>
    </div>
    <!-- Board Column -->
    <div id="boardContainer">
      <canvas id="boardCanvas" width="720" height="800"></canvas>
    </div>
    <!-- Dice Column (Side) -->
    <div id="diceContainer">
      <canvas id="diceCanvas" width="250" height="150"></canvas>
      <button id="rollBtn" style="display: none;">Roll Dice</button>
      <p id="diceResult"></p>
    </div>
  </div>

  <script>
    /***********************************
     * Utility & Bug Logging
     ***********************************/
    let bugLogs = [];
    function logBug(loc, details) {
      const entry = { time: new Date().toISOString(), loc, details };
      bugLogs.push(entry);
      console.error("Bug:", entry);
    }
    window.onerror = (msg, src, line, col, err) =>
      logBug("Global", { msg, src, line, col, err });

    /***********************************
     * Global Variables & Constants
     ***********************************/
    const boardCanvas = document.getElementById("boardCanvas");
    const ctx = boardCanvas.getContext("2d");
    const barCanvas = document.getElementById("barCanvas");
    const barCtx = barCanvas.getContext("2d");
    const diceCanvas = document.getElementById("diceCanvas");
    const diceCtx = diceCanvas.getContext("2d");
    const rollBtn = document.getElementById("rollBtn");
    const diceResultP = document.getElementById("diceResult");

    // Overlays
    const menuScreen = document.getElementById("menuScreen");
    const colorScreen = document.getElementById("colorScreen");
    const difficultyScreen = document.getElementById("difficultyScreen");
    const instructionsScreen = document.getElementById("instructionsScreen");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const gameOverText = document.getElementById("gameOverText");

    // Board layout – canvas size 720×800
    const WIDTH = boardCanvas.width;  // 720
    const HEIGHT = boardCanvas.height; // 800
    const boardMargin = 20;
    const barWidth = 40;
    const bearOffTop = 150;
    const bearOffBottom = 100;
    const boardTop = bearOffTop;
    const boardHeight = HEIGHT - bearOffTop - bearOffBottom;
    const boardWidth = WIDTH - 2 * boardMargin - barWidth;
    const pointWidth = boardWidth / 12;

    // Colors
    const whiteColor = "#fff";
    const blackColor = "#000";

    // Board state: 24 points (0–11: bottom row [points 1–12], 12–23: top row [points 13–24])
    let board = new Array(24).fill(null);
    board[23] = { owner: 'w', count: 2 };
    board[12] = { owner: 'w', count: 5 };
    board[7]  = { owner: 'w', count: 3 };
    board[5]  = { owner: 'w', count: 5 };
    board[0]  = { owner: 'b', count: 2 };
    board[11] = { owner: 'b', count: 5 };
    board[16] = { owner: 'b', count: 3 };
    board[18] = { owner: 'b', count: 5 };

    // Bar & borne-off state
    let bar = { w: 0, b: 0 };
    let borneOff = { w: 0, b: 0 };

    // Movement variables
    let selectedPoint = null;
    let legalMoves = [];
    let currentDice = [];

    // Turn control: Human will choose color.
    let currentTurn = "w"; // will be set via overlay

    // Dice animation duration (ms)
    const diceAnimationDuration = 1000;

    // Difficulty (affects AI delay)
    let difficulty = "easy";

    /***********************************
     * Overlay & Menu Management
     ***********************************/
    function hideAllScreens() {
      menuScreen.style.display = "none";
      colorScreen.style.display = "none";
      difficultyScreen.style.display = "none";
      instructionsScreen.style.display = "none";
      gameOverScreen.style.display = "none";
    }
    function showMenu() {
      hideAllScreens();
      menuScreen.style.display = "flex";
    }
    function showColorChoice() {
      hideAllScreens();
      colorScreen.style.display = "flex";
    }
    function showDifficultyChoice() {
      hideAllScreens();
      difficultyScreen.style.display = "flex";
    }
    function showInstructions() {
      hideAllScreens();
      instructionsScreen.style.display = "flex";
    }
    function showGameOver(message) {
      hideAllScreens();
      gameOverText.textContent = message;
      gameOverScreen.style.display = "flex";
    }

    document.getElementById("newGameBtn").onclick = () => { showColorChoice(); };
    document.getElementById("instructionsBtn").onclick = () => { showInstructions(); };
    document.getElementById("whiteSideBtn").onclick = () => {
      playerColor = "w";
      currentTurn = "w"; // Human starts if white
      showDifficultyChoice();
    };
    document.getElementById("blackSideBtn").onclick = () => {
      playerColor = "b";
      currentTurn = "b"; // Human starts if black
      showDifficultyChoice();
    };
    document.getElementById("easyBtn").onclick = () => { difficulty = "easy"; startGame(); };
    document.getElementById("mediumBtn").onclick = () => { difficulty = "medium"; startGame(); };
    document.getElementById("hardBtn").onclick = () => { difficulty = "hard"; startGame(); };
    document.getElementById("gameOverNewGameBtn").onclick = () => { showColorChoice(); };

    document.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      if (colorScreen.style.display === "flex") {
        if (key === "w") document.getElementById("whiteSideBtn").click();
        if (key === "b") document.getElementById("blackSideBtn").click();
      } else if (difficultyScreen.style.display === "flex") {
        if (key === "e") document.getElementById("easyBtn").click();
        if (key === "m") document.getElementById("mediumBtn").click();
        if (key === "h") document.getElementById("hardBtn").click();
      } else if (["playing", "instructions", "game_over"].includes(gameState)) {
        if (key === "m") showMenu();
      }
    });

    let gameState = "menu";

    /***********************************
     * Board Drawing Functions
     ***********************************/
    function drawBoard() {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      // Draw White Bear-Off Zone (top)
      ctx.fillStyle = "#e0e0e0";
      ctx.fillRect(boardMargin, 20, WIDTH - 2 * boardMargin, bearOffTop - 20);
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 3;
      ctx.strokeRect(boardMargin, 20, WIDTH - 2 * boardMargin, bearOffTop - 20);
      ctx.font = "18px sans-serif";
      ctx.fillStyle = "blue";
      ctx.textAlign = "center";
      ctx.fillText("White Bear Off", WIDTH / 2, 40);

      // Draw Black Bear-Off Zone (bottom)
      ctx.fillStyle = "#e0e0e0";
      ctx.fillRect(boardMargin, boardTop + boardHeight + 20, WIDTH - 2 * boardMargin, bearOffBottom - 20);
      ctx.strokeStyle = "blue";
      ctx.strokeRect(boardMargin, boardTop + boardHeight + 20, WIDTH - 2 * boardMargin, bearOffBottom - 20);
      ctx.fillStyle = "blue";
      ctx.fillText("Black Bear Off", WIDTH / 2, boardTop + boardHeight + 40);

      // Draw main board background
      ctx.fillStyle = "#f5f5f5";
      ctx.fillRect(0, boardTop, WIDTH, boardHeight);

      // Draw board halves (green)
      ctx.fillStyle = "#006400";
      ctx.fillRect(boardMargin, boardTop, boardWidth/2, boardHeight);
      ctx.fillRect(boardMargin + boardWidth/2 + barWidth, boardTop, boardWidth/2, boardHeight);

      // Draw central bar
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(boardMargin + boardWidth/2, boardTop, barWidth, boardHeight);

      // Draw triangles for bottom row (points 1–12) – drawn right-to‑left
      for (let p = 1; p <= 12; p++) {
        let pos = 12 - p;
        let x = boardMargin + pos * pointWidth;
        let y = boardTop + boardHeight - boardHeight/2;
        let direction = "up";
        let color = (p % 2 === 0) ? "#deb887" : "#d2b48c";
        drawTriangle(x, y, pointWidth, boardHeight/2, direction, color);
      }
      // Draw triangles for top row (points 13–24) – drawn left-to‑right
      for (let p = 13; p <= 24; p++) {
        let idx = p - 13;
        let x = boardMargin + idx * pointWidth;
        let y = boardTop;
        let direction = "down";
        let color = (p % 2 === 0) ? "#deb887" : "#d2b48c";
        drawTriangle(x, y, pointWidth, boardHeight/2, direction, color);
      }
      drawBearOffPieces();
    }

    function drawTriangle(x, y, width, height, direction, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      if (direction === "up") {
        ctx.moveTo(x, y + height);
        ctx.lineTo(x + width/2, y);
        ctx.lineTo(x + width, y + height);
      } else {
        ctx.moveTo(x, y);
        ctx.lineTo(x + width/2, y + height);
        ctx.lineTo(x + width, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.stroke();
    }

    function getTriangleCoordinates(idx) {
      let x, y, width = pointWidth, height;
      if (idx >= 12 && idx <= 23) {
        let p = idx + 1;
        x = boardMargin + (p - 13) * pointWidth;
        y = boardTop;
        height = boardHeight/2;
        return { x, y, width, height };
      } else if (idx >= 0 && idx <= 11) {
        let p = idx + 1;
        let pos = 12 - p;
        x = boardMargin + pos * pointWidth;
        y = boardTop + boardHeight/2;
        height = boardHeight/2;
        return { x, y, width, height };
      }
      return null;
    }

    function drawBearOffPieces() {
      const pieceRadius = 15, spacing = pieceRadius * 2.2;
      // White borne-off pieces: drawn along bottom edge of top zone
      for (let i = 0; i < borneOff.w; i++) {
        let cx = boardMargin + 30 + i * spacing;
        let cy = boardTop - 30;
        drawChecker(cx, cy, pieceRadius, 'w');
      }
      // Black borne-off pieces: drawn along top edge of bottom zone
      for (let i = 0; i < borneOff.b; i++) {
        let cx = boardMargin + 30 + i * spacing;
        let cy = boardTop + boardHeight + 50;
        drawChecker(cx, cy, pieceRadius, 'b');
      }
    }

    function drawChecker(cx, cy, radius, owner) {
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
      ctx.fillStyle = owner === 'w' ? whiteColor : blackColor;
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.stroke();
    }

    function drawPieces() {
      for (let i = 0; i < 24; i++) {
        if (!board[i]) continue;
        let tri = getTriangleCoordinates(i);
        let centerX = tri.x + tri.width/2;
        let spacing = Math.min(tri.width, tri.height) / 3;
        for (let j = 0; j < board[i].count; j++) {
          let centerY;
          if (i < 12) {
            centerY = tri.y + tri.height - (j + 0.5) * spacing;
          } else {
            centerY = tri.y + (j + 0.5) * spacing;
          }
          drawChecker(centerX, centerY, 15, board[i].owner);
        }
      }
    }

    function redrawBoard() {
      drawBoard();
      drawPieces();
    }

    /***********************************
     * Dice Functions & Animation
     ***********************************/
    function rollDiceSimple() {
      return [Math.floor(Math.random() * 6) + 1, Math.floor(Math.random() * 6) + 1];
    }
    function drawDie(x, y, size, value) {
      diceCtx.fillStyle = "#fff";
      diceCtx.fillRect(x, y, size, size);
      diceCtx.strokeStyle = "#000";
      diceCtx.strokeRect(x, y, size, size);
      diceCtx.fillStyle = "#000";
      const dotRadius = size / 10;
      const cx = x + size / 2;
      const cy = y + size / 2;
      const dots = {
        1: [{ x: cx, y: cy }],
        2: [{ x: x + size * 0.25, y: y + size * 0.25 }, { x: x + size * 0.75, y: y + size * 0.75 }],
        3: [{ x: x + size * 0.25, y: y + size * 0.25 }, { x: cx, y: cy }, { x: x + size * 0.75, y: y + size * 0.75 }],
        4: [{ x: x + size * 0.25, y: y + size * 0.25 }, { x: x + size * 0.75, y: y + size * 0.25 },
            { x: x + size * 0.25, y: y + size * 0.75 }, { x: x + size * 0.75, y: y + size * 0.75 }],
        5: [{ x: x + size * 0.25, y: y + size * 0.25 }, { x: x + size * 0.75, y: y + size * 0.25 },
            { x: cx, y: cy },
            { x: x + size * 0.25, y: y + size * 0.75 }, { x: x + size * 0.75, y: y + size * 0.75 }],
        6: [{ x: x + size * 0.25, y: y + size * 0.25 }, { x: x + size * 0.75, y: y + size * 0.25 },
            { x: x + size * 0.25, y: y + size * 0.5 }, { x: x + size * 0.75, y: y + size * 0.5 },
            { x: x + size * 0.25, y: y + size * 0.75 }, { x: x + size * 0.75, y: y + size * 0.75 }]
      };
      dots[value].forEach(dot => {
        diceCtx.beginPath();
        diceCtx.arc(dot.x, dot.y, dotRadius, 0, 2 * Math.PI);
        diceCtx.fill();
      });
    }
    function drawDice(dice) {
      diceCtx.clearRect(0, 0, diceCanvas.width, diceCanvas.height);
      const dieSize = 100;
      drawDie(20, 25, dieSize, dice[0]);
      drawDie(130, 25, dieSize, dice[1]);
      diceResultP.textContent = `Result: ${dice[0]} & ${dice[1]}`;
    }
    function animateDice(finalDice, duration, callback) {
      let startTime = Date.now();
      let interval = setInterval(() => {
        let elapsed = Date.now() - startTime;
        if (elapsed < duration) {
          let tempDice = [Math.floor(Math.random() * 6) + 1, Math.floor(Math.random() * 6) + 1];
          drawDice(tempDice);
        } else {
          clearInterval(interval);
          drawDice(finalDice);
          if (callback) callback();
        }
      }, 100);
    }
    rollBtn.addEventListener("click", () => {
      const finalDice = rollDiceSimple();
      animateDice(finalDice, diceAnimationDuration, () => {
        currentDice = finalDice;
        console.log("Final dice:", finalDice);
      });
    });

    /***********************************
     * Advanced Movement & Rules
     ***********************************/
    // Note: In this version, White moves from point 24 to 1 (by subtracting the die)
    // and Black moves from point 1 to 24 (by adding the die).
    // Re-entry: White re-enters into points 24–19 (indices 23–18); Black re-enters into points 1–6 (indices 0–5).
    // Bearing off: White can bear off if all its checkers are in points 1–6 (indices 0–5);
    //             Black can bear off if all its checkers are in points 19–24 (indices 18–23).
    function allCheckersInHome(color) {
      for (let i = 0; i < 24; i++) {
        if (board[i] && board[i].owner === color) {
          if (color === 'w' && i > 5) return false;
          if (color === 'b' && i < 18) return false;
        }
      }
      return (bar[color] === 0);
    }

    function getLegalMoves(pointIndex) {
      let moves = [];
      if (!board[pointIndex] || board[pointIndex].owner !== currentTurn) return moves;
      currentDice.forEach(die => {
        let dest;
        if (currentTurn === 'w') {
          dest = pointIndex - die;
          if (dest < 0 && allCheckersInHome('w')) {
            moves.push({ from: pointIndex, to: -1, die, bearOff: true });
          } else if (dest >= 0) {
            if (!board[dest] || board[dest].owner === currentTurn ||
                (board[dest].owner !== currentTurn && board[dest].count === 1)) {
              moves.push({ from: pointIndex, to: dest, die, hit: (board[dest] && board[dest].owner !== currentTurn && board[dest].count === 1) || false });
            }
          }
        } else {
          dest = pointIndex + die;
          if (dest > 23 && allCheckersInHome('b')) {
            moves.push({ from: pointIndex, to: 24, die, bearOff: true });
          } else if (dest <= 23) {
            if (!board[dest] || board[dest].owner === currentTurn ||
                (board[dest].owner !== currentTurn && board[dest].count === 1)) {
              moves.push({ from: pointIndex, to: dest, die, hit: (board[dest] && board[dest].owner !== currentTurn && board[dest].count === 1) || false });
            }
          }
        }
      });
      return moves;
    }

    function getLegalMovesFromBar() {
      let moves = [];
      if (bar[currentTurn] <= 0) return moves;
      currentDice.forEach(die => {
        let dest;
        if (currentTurn === 'w') {
          dest = 24 - die;
        } else {
          dest = die - 1;
        }
        if (dest < 0 || dest > 23) return;
        if (!board[dest] || board[dest].owner === currentTurn ||
            (board[dest].owner !== currentTurn && board[dest].count === 1)) {
          moves.push({ from: "bar", to: dest, die, hit: (board[dest] && board[dest].owner !== currentTurn && board[dest].count === 1) || false });
        }
      });
      return moves;
    }

    function makeMove(move) {
      if (move.from === "bar") {
        bar[currentTurn]--;
      } else {
        if (board[move.from]) {
          board[move.from].count--;
          if (board[move.from].count === 0) board[move.from] = null;
        }
      }
      if (move.bearOff) {
        borneOff[currentTurn]++;
      } else {
        if (move.hit) {
          let opp = currentTurn === 'w' ? 'b' : 'w';
          bar[opp]++;
          board[move.to] = { owner: currentTurn, count: 1 };
        } else {
          if (!board[move.to]) {
            board[move.to] = { owner: currentTurn, count: 1 };
          } else {
            board[move.to].count++;
          }
        }
      }
      let idx = currentDice.indexOf(move.die);
      if (idx !== -1) currentDice.splice(idx, 1);
      selectedPoint = null;
      legalMoves = [];
    }

    /***********************************
     * Human Input Handling
     ***********************************/
    boardCanvas.addEventListener("mousedown", (e) => {
      if (currentTurn !== "w") return; // Human is White
      const rect = boardCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      let clicked = getPointFromCoordinates(mx, my);
      if (clicked === null) return;
      // If checkers on bar, force re-entry
      if (bar[currentTurn] > 0) {
        let reEntryMoves = getLegalMovesFromBar();
        if (!reEntryMoves.length) return;
        selectedPoint = "bar";
        legalMoves = reEntryMoves;
        let move = reEntryMoves.find(m => m.to === clicked);
        if (move) {
          makeMove(move);
          redrawBoard();
          drawBarPieces();
          return;
        }
        return;
      }
      if (selectedPoint === null) {
        if (board[clicked] && board[clicked].owner === currentTurn) {
          selectedPoint = clicked;
          legalMoves = getLegalMoves(clicked);
        }
      } else {
        let move = legalMoves.find(m => m.to === clicked);
        if (move) {
          makeMove(move);
        }
        selectedPoint = null;
        legalMoves = [];
      }
      redrawBoard();
      if (currentDice.length) drawDice(currentDice);
      drawBarPieces();
    });

    function getPointFromCoordinates(x, y) {
      if (y < boardTop || y > boardTop + boardHeight) return null;
      let pt;
      if (y < boardTop + boardHeight/2) {
        let pos = Math.floor((x - boardMargin) / pointWidth);
        pt = pos + 13;
      } else {
        let pos = Math.floor((x - boardMargin) / pointWidth);
        pt = 12 - pos;
      }
      return pt - 1;
    }

    /***********************************
     * Highlight Legal Moves (Improved)
     ***********************************/
    function highlightLegalOptions() {
      if (selectedPoint !== null) {
        let selCoords = getTriangleCoordinates(selectedPoint);
        if (selCoords) {
          ctx.strokeStyle = "red";
          ctx.lineWidth = 4;
          ctx.strokeRect(selCoords.x, selCoords.y, selCoords.width, selCoords.height);
        }
        legalMoves.forEach(move => {
          let dest = getTriangleCoordinates(move.to);
          if (dest) {
            ctx.strokeStyle = "yellow";
            ctx.lineWidth = 4;
            ctx.strokeRect(dest.x, dest.y, dest.width, dest.height);
          }
        });
      }
    }

    /***********************************
     * AI Turn (Random Moves for Black)
     ***********************************/
    function aiTurn() {
      if (currentTurn === "w") return; // Human is White
      setTimeout(() => {
        if (currentDice.length === 0) {
          let finalDice = rollDiceSimple();
          animateDice(finalDice, diceAnimationDuration, () => {
            currentDice = finalDice;
            aiTurn();
          });
          return;
        }
        let moves = [];
        if (bar[currentTurn] > 0) {
          moves = getLegalMovesFromBar();
        } else {
          for (let i = 0; i < 24; i++) {
            if (board[i] && board[i].owner === currentTurn) {
              let legal = getLegalMoves(i);
              if (legal.length) moves = moves.concat(legal);
            }
          }
        }
        if (moves.length === 0) {
          currentDice = [];
          endTurn();
          return;
        }
        let move = moves[Math.floor(Math.random() * moves.length)];
        makeMove(move);
        redrawBoard();
        drawBarPieces();
        if (currentDice.length > 0 && !hasLegalMoves()) {
          currentDice = [];
          endTurn();
        } else if (currentDice.length > 0) {
          aiTurn();
        } else {
          endTurn();
        }
      }, getAIDelay());
    }

    function hasLegalMoves() {
      let moves = [];
      if (bar[currentTurn] > 0) {
        moves = getLegalMovesFromBar();
      } else {
        for (let i = 0; i < 24; i++) {
          if (board[i] && board[i].owner === currentTurn) {
            let legal = getLegalMoves(i);
            if (legal.length) moves = moves.concat(legal);
          }
        }
      }
      return moves.length > 0;
    }

    function getAIDelay() {
      if (difficulty === "hard") return 1000;
      if (difficulty === "medium") return 1500;
      return 2000;
    }

    function endTurn() {
      currentTurn = (currentTurn === "w") ? "b" : "w";
      currentDice = [];
      if (!checkGameOver()) {
        if (currentTurn === "w") {
          rollBtn.style.display = "block";
        } else {
          rollBtn.style.display = "none";
          aiTurn();
        }
      }
    }

    function checkGameOver() {
      if (borneOff.w >= 15) {
        showGameOver("Game Over: White wins!");
        return true;
      }
      if (borneOff.b >= 15) {
        showGameOver("Game Over: Black wins!");
        return true;
      }
      return false;
    }

    /***********************************
     * Redraw & Main Loop
     ***********************************/
    function redrawBoard() {
      drawBoard();
      drawPieces();
    }
    function redraw() {
      redrawBoard();
      highlightLegalOptions();
      if (currentDice.length) drawDice(currentDice);
      drawBarPieces();
    }
    function mainLoop() {
      redraw();
      requestAnimationFrame(mainLoop);
    }
    window.addEventListener("load", () => { mainLoop(); });

    /***********************************
     * Bar Pieces Drawing
     ***********************************/
    function drawBarPieces() {
      barCtx.clearRect(0, 0, barCanvas.width, barCanvas.height);
      barCtx.font = "16px sans-serif";
      barCtx.fillStyle = "#000";
      barCtx.fillText("Bar", barCanvas.width/2, 20);
      const pieceRadius = 15, spacing = pieceRadius * 2.2;
      for (let j = 0; j < bar.w; j++) {
        let cx = barCanvas.width/2, cy = 40 + j * spacing;
        barCtx.beginPath();
        barCtx.arc(cx, cy, pieceRadius, 0, 2*Math.PI);
        barCtx.fillStyle = "#fff";
        barCtx.fill();
        barCtx.strokeStyle = "#000";
        barCtx.stroke();
      }
      for (let j = 0; j < bar.b; j++) {
        let cx = barCanvas.width/2, cy = barCanvas.height - 40 - j * spacing;
        barCtx.beginPath();
        barCtx.arc(cx, cy, pieceRadius, 0, 2*Math.PI);
        barCtx.fillStyle = "#000";
        barCtx.fill();
        barCtx.strokeStyle = "#000";
        barCtx.stroke();
      }
    }

    /***********************************
     * Human Input Handling
     ***********************************/
    boardCanvas.addEventListener("mousedown", (e) => {
      if (currentTurn !== "w") return;
      const rect = boardCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      let clicked = getPointFromCoordinates(mx, my);
      if (clicked === null) return;
      if (bar[currentTurn] > 0) {
        let reEntryMoves = getLegalMovesFromBar();
        if (!reEntryMoves.length) return;
        selectedPoint = "bar";
        legalMoves = reEntryMoves;
        let move = reEntryMoves.find(m => m.to === clicked);
        if (move) {
          makeMove(move);
          redrawBoard();
          drawBarPieces();
          return;
        }
        return;
      }
      if (selectedPoint === null) {
        if (board[clicked] && board[clicked].owner === currentTurn) {
          selectedPoint = clicked;
          legalMoves = getLegalMoves(clicked);
        }
      } else {
        let move = legalMoves.find(m => m.to === clicked);
        if (move) {
          makeMove(move);
        }
        selectedPoint = null;
        legalMoves = [];
      }
      redrawBoard();
      if (currentDice.length) drawDice(currentDice);
      drawBarPieces();
    });

    function getPointFromCoordinates(x, y) {
      if (y < boardTop || y > boardTop + boardHeight) return null;
      let pt;
      if (y < boardTop + boardHeight/2) {
        let pos = Math.floor((x - boardMargin) / pointWidth);
        pt = pos + 13;
      } else {
        let pos = Math.floor((x - boardMargin) / pointWidth);
        pt = 12 - pos;
      }
      return pt - 1;
    }

    /***********************************
     * Dice Roll & Animation
     ***********************************/
    function rollDiceSimple() {
      return [Math.floor(Math.random()*6)+1, Math.floor(Math.random()*6)+1];
    }
    function drawDice(dice) {
      diceCtx.clearRect(0, 0, diceCanvas.width, diceCanvas.height);
      const dieSize = 100;
      drawDie(20, 25, dieSize, dice[0]);
      drawDie(130, 25, dieSize, dice[1]);
      diceResultP.textContent = `Result: ${dice[0]} & ${dice[1]}`;
    }
    function animateDice(finalDice, duration, callback) {
      let startTime = Date.now();
      let interval = setInterval(() => {
        let elapsed = Date.now() - startTime;
        if (elapsed < duration) {
          let tempDice = [Math.floor(Math.random()*6)+1, Math.floor(Math.random()*6)+1];
          drawDice(tempDice);
        } else {
          clearInterval(interval);
          drawDice(finalDice);
          if (callback) callback();
        }
      }, 100);
    }
    rollBtn.addEventListener("click", () => {
      const finalDice = rollDiceSimple();
      animateDice(finalDice, diceAnimationDuration, () => {
        currentDice = finalDice;
        console.log("Final dice:", finalDice);
      });
    });

    /***********************************
     * Redraw & Main Loop
     ***********************************/
    function redrawBoard() {
      drawBoard();
      drawPieces();
    }
    function redraw() {
      redrawBoard();
      highlightLegalOptions();
      if (currentDice.length) drawDice(currentDice);
      drawBarPieces();
    }
    function mainLoop() {
      redraw();
      requestAnimationFrame(mainLoop);
    }
    window.addEventListener("load", () => { mainLoop(); });

    /***********************************
     * Game Over & AI
     ***********************************/
    function showGameOver(message) {
      hideAllScreens();
      gameState = "game_over";
      gameOverText.textContent = message;
      gameOverScreen.style.display = "flex";
    }
    function endTurn() {
      currentTurn = (currentTurn === "w") ? "b" : "w";
      currentDice = [];
      if (!checkGameOver()) {
        if (currentTurn === "w") {
          rollBtn.style.display = "block";
        } else {
          rollBtn.style.display = "none";
          aiTurn();
        }
      }
    }
    function checkGameOver() {
      if (borneOff.w >= 15) {
        showGameOver("Game Over: White wins!");
        return true;
      }
      if (borneOff.b >= 15) {
        showGameOver("Game Over: Black wins!");
        return true;
      }
      return false;
    }
    function aiTurn() {
      if (currentTurn === "w") return;
      setTimeout(() => {
        if (currentDice.length === 0) {
          let finalDice = rollDiceSimple();
          animateDice(finalDice, diceAnimationDuration, () => {
            currentDice = finalDice;
            aiTurn();
          });
          return;
        }
        let moves = [];
        if (bar[currentTurn] > 0) {
          moves = getLegalMovesFromBar();
        } else {
          for (let i = 0; i < 24; i++) {
            if (board[i] && board[i].owner === currentTurn) {
              let legal = getLegalMoves(i);
              if (legal.length) moves = moves.concat(legal);
            }
          }
        }
        if (moves.length === 0) {
          currentDice = [];
          endTurn();
          return;
        }
        let move = moves[Math.floor(Math.random() * moves.length)];
        makeMove(move);
        redrawBoard();
        drawBarPieces();
        if (currentDice.length > 0 && !hasLegalMoves()) {
          currentDice = [];
          endTurn();
        } else if (currentDice.length > 0) {
          aiTurn();
        } else {
          endTurn();
        }
      }, getAIDelay());
    }
    function hasLegalMoves() {
      let moves = [];
      if (bar[currentTurn] > 0) {
        moves = getLegalMovesFromBar();
      } else {
        for (let i = 0; i < 24; i++) {
          if (board[i] && board[i].owner === currentTurn) {
            let legal = getLegalMoves(i);
            if (legal.length) moves = moves.concat(legal);
          }
        }
      }
      return moves.length > 0;
    }
    function getAIDelay() {
      if (difficulty === "hard") return 1000;
      if (difficulty === "medium") return 1500;
      return 2000;
    }

    /***********************************
     * Start Game
     ***********************************/
    function startGame() {
      hideAllScreens();
      gameState = "playing";
      // Reset board state to standard starting positions
      board = new Array(24).fill(null);
      board[23] = { owner: 'w', count: 2 };
      board[12] = { owner: 'w', count: 5 };
      board[7]  = { owner: 'w', count: 3 };
      board[5]  = { owner: 'w', count: 5 };
      board[0]  = { owner: 'b', count: 2 };
      board[11] = { owner: 'b', count: 5 };
      board[16] = { owner: 'b', count: 3 };
      board[18] = { owner: 'b', count: 5 };
      bar = { w: 0, b: 0 };
      borneOff = { w: 0, b: 0 };
      currentDice = [];
      selectedPoint = null;
      legalMoves = [];
      redrawBoard();
      if (currentTurn === playerColor) {
        rollBtn.style.display = "block";
      } else {
        rollBtn.style.display = "none";
        aiTurn();
      }
    }
    document.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      if (colorScreen.style.display === "flex") {
        if (key === "w") document.getElementById("whiteSideBtn").click();
        if (key === "b") document.getElementById("blackSideBtn").click();
      } else if (difficultyScreen.style.display === "flex") {
        if (key === "e") document.getElementById("easyBtn").click();
        if (key === "m") document.getElementById("mediumBtn").click();
        if (key === "h") document.getElementById("hardBtn").click();
      } else if (["playing", "instructions", "game_over"].includes(gameState)) {
        if (key === "m") showMenu();
      }
    });
    let gameState = "menu";
    document.getElementById("newGameBtn").onclick = () => { showColorChoice(); };
    document.getElementById("instructionsBtn").onclick = () => { showInstructions(); };
    document.getElementById("whiteSideBtn").onclick = () => {
      playerColor = "w";
      currentTurn = "w";
      showDifficultyChoice();
    };
    document.getElementById("blackSideBtn").onclick = () => {
      playerColor = "b";
      currentTurn = "b";
      showDifficultyChoice();
    };
    document.getElementById("easyBtn").onclick = () => { difficulty = "easy"; startGame(); };
    document.getElementById("mediumBtn").onclick = () => { difficulty = "medium"; startGame(); };
    document.getElementById("hardBtn").onclick = () => { difficulty = "hard"; startGame(); };
    document.getElementById("gameOverNewGameBtn").onclick = () => { showColorChoice(); };

    /***********************************
     * Redraw & Main Loop
     ***********************************/
    function redraw() {
      redrawBoard();
      highlightLegalOptions();
      if (currentDice.length) drawDice(currentDice);
      drawBarPieces();
    }
    function mainLoop() {
      redraw();
      requestAnimationFrame(mainLoop);
    }
    window.addEventListener("load", () => { mainLoop(); });

    /***********************************
     * Bar Pieces Drawing
     ***********************************/
    function drawBarPieces() {
      barCtx.clearRect(0, 0, barCanvas.width, barCanvas.height);
      barCtx.font = "16px sans-serif";
      barCtx.fillStyle = "#000";
      barCtx.fillText("Bar", barCanvas.width/2, 20);
      const pieceRadius = 15, spacing = pieceRadius * 2.2;
      for (let j = 0; j < bar.w; j++) {
        let cx = barCanvas.width/2, cy = 40+j*spacing;
        barCtx.beginPath();
        barCtx.arc(cx, cy, pieceRadius, 0, 2*Math.PI);
        barCtx.fillStyle = "#fff";
        barCtx.fill();
        barCtx.strokeStyle = "#000";
        barCtx.stroke();
      }
      for (let j = 0; j < bar.b; j++) {
        let cx = barCanvas.width/2, cy = barCanvas.height-40-j*spacing;
        barCtx.beginPath();
        barCtx.arc(cx, cy, pieceRadius, 0, 2*Math.PI);
        barCtx.fillStyle = "#000";
        barCtx.fill();
        barCtx.strokeStyle = "#000";
        barCtx.stroke();
      }
    }
  </script>
</body>
</html>
