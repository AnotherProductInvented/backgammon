<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented Backgammon</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 1rem 0 0.5rem;
      text-align: center;
    }
    #gameContainer {
      position: relative;
      width: 720px;
      max-width: 100%;
    }
    canvas {
      display: block;
      background: #f5f5f5;
      width: 100%;
      height: auto;
    }
    .overlayScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      background: rgba(255,255,255,0.95);
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      z-index: 5;
    }
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
    }
    /* Loading overlay with spinner */
    #loadingOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      color: #fff;
      font-size: 24px;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 1000;
    }
    .spinner {
      border: 8px solid rgba(255,255,255,0.3);
      border-top: 8px solid #fff;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    /* Logo placed in bottom-right corner */
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <!-- MENU SCREEN -->
    <div id="menuScreen" class="overlayScreen" style="display: flex;">
      <h1 style="margin:0;">Another Product Invented<br>Backgammon</h1>
      <button id="newGameBtn">New Game</button>
      <button id="instructionsBtn">Instructions</button>
    </div>
    <!-- COLOR CHOICE SCREEN -->
    <div id="colorScreen" class="overlayScreen">
      <p>Choose Your Color:</p>
      <button id="whiteSideBtn">White [W]</button>
      <button id="blackSideBtn">Black [B]</button>
      <p>You can also press W or B on your keyboard.</p>
    </div>
    <!-- DIFFICULTY SCREEN -->
    <div id="difficultyScreen" class="overlayScreen">
      <p>Select Difficulty:</p>
      <button id="easyBtn">Easy [E]</button>
      <button id="mediumBtn">Medium [M]</button>
      <button id="hardBtn">Hard [H]</button>
      <p>You can also press E, M, or H on your keyboard.</p>
    </div>
    <!-- INSTRUCTIONS SCREEN -->
    <div id="instructionsScreen" class="overlayScreen">
      <h2>How to Play Backgammon</h2>
      <p>
        The objective is to move all your checkers to your home board and bear them off.
        On your turn, roll the dice and move your checkers according to the dice values.
        You may hit an opponent's single checker and send it to the bar.
        If you have checkers on the bar, you must re-enter them before making other moves.
        Bear off your checkers once all are in your home board.
      </p>
      <p>Press [M] to return to the Main Menu.</p>
    </div>
    <!-- GAME OVER SCREEN -->
    <div id="gameOverScreen" class="overlayScreen">
      <h2 id="gameOverText"></h2>
      <button id="gameOverNewGameBtn">New Game</button>
      <p>Press [M] to return to the Main Menu.</p>
    </div>
    <!-- Roll Dice button appears during play -->
    <button id="rollDiceBtn" style="position:absolute; top:10px; right:10px; display:none;">Roll Dice</button>
    <!-- Backgammon Canvas -->
    <canvas id="backgammonCanvas" width="720" height="800"></canvas>
  </div>
  <!-- Logo -->
  <img id="logo" src="logo.png" alt="Logo">
  <!-- Loading Overlay with Spinner -->
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <p>Processing...</p>
  </div>
  <script>
    /************ Bug Detection & Logging ************/
    let bugLogs = [];
    function logBug(location, details) {
      const timestamp = new Date().toISOString();
      const logEntry = { timestamp, location, details };
      bugLogs.push(logEntry);
      console.error("Bug Logged:", logEntry);
    }
    window.onerror = function(message, source, lineno, colno, error) {
      logBug("Global Error", { message, source, lineno, colno, error });
    };

    /************ Global Variables & Constants ************/
    const canvas = document.getElementById("backgammonCanvas");
    const ctx = canvas.getContext("2d");

    const menuScreen = document.getElementById("menuScreen");
    const instructionsScreen = document.getElementById("instructionsScreen");
    const colorScreen = document.getElementById("colorScreen");
    const difficultyScreen = document.getElementById("difficultyScreen");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const gameOverText = document.getElementById("gameOverText");
    const rollDiceBtn = document.getElementById("rollDiceBtn");
    const loadingOverlay = document.getElementById("loadingOverlay");

    const WIDTH = 720, HEIGHT = 800;
    let gameState = "menu";  // "menu", "instructions", "color_choice", "difficulty_choice", "playing", "game_over"
    let playerColor = null;  // "w" or "b"
    let difficulty = null;   // "easy", "medium", "hard"
    let currentTurn = "w";   // white moves first
    let selectedPoint = null;
    let legalMoves = [];
    let currentDice = [];    // Array of dice values available this turn (e.g. [3,5] or [4,4,4,4])
    let aiThinking = false;
    let borneOff = { w: 0, b: 0 };

    // Board representation: Array of 24 points (index 0 = point 1, index 23 = point 24)
    // Each point: { owner: 'w' or 'b', count: number }
    let board = new Array(24).fill(null);
    // Bar for hit checkers: { w: number, b: number }
    let bar = { w: 0, b: 0 };

    /************ Game Initialization ************/
    // Standard backgammon starting positions
    function initBoard() {
      try {
        board.fill(null);
        borneOff = { w: 0, b: 0 };
        bar = { w: 0, b: 0 };
        // White checkers
        board[23] = { owner: 'w', count: 2 };  // Point 24
        board[12] = { owner: 'w', count: 5 };  // Point 13
        board[7]  = { owner: 'w', count: 3 };  // Point 8
        board[5]  = { owner: 'w', count: 5 };  // Point 6
        // Black checkers
        board[0]  = { owner: 'b', count: 2 };   // Point 1
        board[11] = { owner: 'b', count: 5 };   // Point 12
        board[16] = { owner: 'b', count: 3 };   // Point 17
        board[18] = { owner: 'b', count: 5 };   // Point 19
        currentTurn = "w";
        currentDice = [];
        selectedPoint = null;
        legalMoves = [];
      } catch (err) {
        logBug("initBoard", err);
      }
    }

    /************ Dice Rolling ************/
    // Roll two dice; if doubles, return four moves.
    function rollDice() {
      try {
        const die1 = Math.floor(Math.random() * 6) + 1;
        const die2 = Math.floor(Math.random() * 6) + 1;
        if (die1 === die2) {
          return [die1, die1, die1, die1];
        }
        return [die1, die2];
      } catch (err) {
        logBug("rollDice", err);
        return [];
      }
    }

    /************ Board & Piece Drawing ************/
    function drawBoard() {
      try {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = "#f5f5f5";
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        const boardMargin = 20;
        const boardWidth = WIDTH - 2 * boardMargin;
        const boardHeight = 600;
        const boardTop = 100;
        // Draw board background
        ctx.fillStyle = "#006400";
        ctx.fillRect(boardMargin, boardTop, boardWidth, boardHeight);
        // Draw central bar
        const barWidth = 24;
        const barX = boardMargin + boardWidth / 2 - barWidth / 2;
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(barX, boardTop, barWidth, boardHeight);
        const pointWidth = (boardWidth - barWidth) / 12;
        const pointHeight = boardHeight / 2;
        // Top half: Points 13 to 24 (indices 12-23)
        for (let i = 0; i < 12; i++) {
          let x;
          if (i < 6) {
            x = boardMargin + (5 - i) * pointWidth;
          } else {
            x = boardMargin + boardWidth - (i - 6 + 1) * pointWidth;
          }
          drawTriangle(x, boardTop, pointWidth, pointHeight, "down", (i % 2 === 0) ? "#deb887" : "#d2b48c");
        }
        // Bottom half: Points 1 to 12 (indices 0-11)
        for (let i = 0; i < 12; i++) {
          let x;
          if (i < 6) {
            x = boardMargin + i * pointWidth;
          } else {
            x = boardMargin + boardWidth - (i - 6 + 1) * pointWidth;
          }
          drawTriangle(x, boardTop + boardHeight - pointHeight, pointWidth, pointHeight, "up", (i % 2 === 0) ? "#deb887" : "#d2b48c");
        }
        drawDiceFaces();
      } catch (err) {
        logBug("drawBoard", err);
      }
    }

    // Draw a triangle (point) on the board.
    function drawTriangle(x, y, width, height, direction, color) {
      try {
        ctx.fillStyle = color;
        ctx.beginPath();
        if (direction === "up") {
          ctx.moveTo(x, y + height);
          ctx.lineTo(x + width / 2, y);
          ctx.lineTo(x + width, y + height);
        } else {
          ctx.moveTo(x, y);
          ctx.lineTo(x + width / 2, y + height);
          ctx.lineTo(x + width, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
      } catch (err) {
        logBug("drawTriangle", err);
      }
    }

    // Draw checkers on the board, on the bar, and show borne off counts.
    function drawPieces() {
      try {
        const boardMargin = 20;
        const boardWidth = WIDTH - 2 * boardMargin;
        const boardTop = 100;
        const boardHeight = 600;
        const barWidth = 24;
        const pointWidth = (boardWidth - barWidth) / 12;
        const pointHeight = boardHeight / 2;
        let pieceRadius = Math.min(pointWidth, pointHeight) / 4;
        ctx.font = "20px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (let i = 0; i < 24; i++) {
          if (!board[i]) continue;
          let point = board[i];
          let isTop = i >= 12;
          let indexInHalf = isTop ? i - 12 : i;
          let x;
          if (isTop) {
            if (indexInHalf < 6) {
              x = boardMargin + (5 - indexInHalf) * pointWidth;
            } else {
              x = boardMargin + boardWidth - (indexInHalf - 6 + 1) * pointWidth;
            }
          } else {
            if (indexInHalf < 6) {
              x = boardMargin + indexInHalf * pointWidth;
            } else {
              x = boardMargin + boardWidth - (indexInHalf - 6 + 1) * pointWidth;
            }
          }
          let centerX = x + pointWidth / 2;
          let spacing = pieceRadius * 2.2;
          for (let j = 0; j < board[i].count; j++) {
            let centerY;
            if (isTop) {
              centerY = boardTop + pieceRadius + j * spacing;
            } else {
              centerY = boardTop + boardHeight - pieceRadius - j * spacing;
            }
            ctx.beginPath();
            ctx.arc(centerX, centerY, pieceRadius, 0, Math.PI * 2);
            ctx.fillStyle = (point.owner === 'w') ? "#fff" : "#000";
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.stroke();
          }
          if (board[i].count > 5) {
            ctx.fillStyle = "red";
            ctx.fillText(board[i].count, centerX, isTop ? boardTop + pieceRadius + 5 * spacing : boardTop + boardHeight - pieceRadius - 5 * spacing);
          }
        }
        // Draw bar pieces
        const barX = boardMargin + boardWidth / 2;
        for (let j = 0; j < bar.w; j++) {
          let centerX = barX + barWidth / 2;
          let centerY = boardTop + pieceRadius + j * (pieceRadius * 2.2);
          ctx.beginPath();
          ctx.arc(centerX, centerY, pieceRadius, 0, Math.PI * 2);
          ctx.fillStyle = "#fff";
          ctx.fill();
          ctx.stroke();
        }
        for (let j = 0; j < bar.b; j++) {
          let centerX = barX + barWidth / 2;
          let centerY = boardTop + boardHeight - pieceRadius - j * (pieceRadius * 2.2);
          ctx.beginPath();
          ctx.arc(centerX, centerY, pieceRadius, 0, Math.PI * 2);
          ctx.fillStyle = "#000";
          ctx.fill();
          ctx.stroke();
        }
        // Display borne off counts
        ctx.fillStyle = "#000";
        ctx.fillText("White Borne Off: " + borneOff.w, WIDTH - 150, boardTop + boardHeight + 30);
        ctx.fillText("Black Borne Off: " + borneOff.b, WIDTH - 150, boardTop - 30);
      } catch (err) {
        logBug("drawPieces", err);
      }
    }

    // Draw two dice with pip representations.
    function drawDiceFaces() {
      try {
        if (currentDice.length === 0) return;
        let diceToShow = currentDice.slice(0,2);
        const diceSize = 50;
        const spacing = 10;
        const startX = WIDTH - (diceSize * 2 + spacing + 20);
        const startY = 20;
        for (let i = 0; i < diceToShow.length; i++) {
          drawDie(startX + i * (diceSize + spacing), startY, diceSize, diceToShow[i]);
        }
      } catch (err) {
        logBug("drawDiceFaces", err);
      }
    }

    // Draw a single die at (x, y) with given size and value.
    function drawDie(x, y, size, value) {
      try {
        ctx.fillStyle = "#fff";
        ctx.fillRect(x, y, size, size);
        ctx.strokeStyle = "#000";
        ctx.strokeRect(x, y, size, size);
        ctx.fillStyle = "#000";
        const dotRadius = size / 10;
        const centerX = x + size / 2;
        const centerY = y + size / 2;
        const positions = {
          topLeft: { x: x + size * 0.25, y: y + size * 0.25 },
          topRight: { x: x + size * 0.75, y: y + size * 0.25 },
          middle: { x: centerX, y: centerY },
          bottomLeft: { x: x + size * 0.25, y: y + size * 0.75 },
          bottomRight: { x: x + size * 0.75, y: y + size * 0.75 },
          middleLeft: { x: x + size * 0.25, y: centerY },
          middleRight: { x: x + size * 0.75, y: centerY }
        };
        function drawDot(pos) {
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, dotRadius, 0, Math.PI * 2);
          ctx.fill();
        }
        switch(value) {
          case 1:
            drawDot(positions.middle);
            break;
          case 2:
            drawDot(positions.topLeft);
            drawDot(positions.bottomRight);
            break;
          case 3:
            drawDot(positions.topLeft);
            drawDot(positions.middle);
            drawDot(positions.bottomRight);
            break;
          case 4:
            drawDot(positions.topLeft);
            drawDot(positions.topRight);
            drawDot(positions.bottomLeft);
            drawDot(positions.bottomRight);
            break;
          case 5:
            drawDot(positions.topLeft);
            drawDot(positions.topRight);
            drawDot(positions.middle);
            drawDot(positions.bottomLeft);
            drawDot(positions.bottomRight);
            break;
          case 6:
            drawDot(positions.topLeft);
            drawDot(positions.topRight);
            drawDot(positions.middleLeft);
            drawDot(positions.middleRight);
            drawDot(positions.bottomLeft);
            drawDot(positions.bottomRight);
            break;
        }
      } catch (err) {
        logBug("drawDie", err);
      }
    }

    function redrawGame() {
      try {
        drawBoard();
        drawPieces();
      } catch (err) {
        logBug("redrawGame", err);
      }
    }

    /************ Move Logic ************/
    // Check if all checkers of a color are in the home board (and none on the bar)
    function canBearOff(color) {
      let inHome = true;
      for (let i = 0; i < 24; i++) {
        if (board[i] && board[i].owner === color) {
          if (color === 'w' && i > 5) { inHome = false; }
          if (color === 'b' && i < 18) { inHome = false; }
        }
      }
      if (bar[color] > 0) inHome = false;
      return inHome;
    }

    // Get legal moves for a checker at board point (if not on the bar)
    function getLegalMoves(pointIndex) {
      let moves = [];
      if (!board[pointIndex] || board[pointIndex].owner !== currentTurn) return moves;
      for (let die of currentDice) {
        let dest;
        if (currentTurn === 'w') {
          dest = pointIndex - die;
          if (dest < 0 && canBearOff('w')) {
            moves.push({from: pointIndex, to: -1, die, bearOff: true});
            continue;
          }
        } else {
          dest = pointIndex + die;
          if (dest > 23 && canBearOff('b')) {
            moves.push({from: pointIndex, to: 24, die, bearOff: true});
            continue;
          }
        }
        if (dest < 0 || dest > 23) continue;
        if (!board[dest]) {
          moves.push({from: pointIndex, to: dest, die});
        } else if (board[dest].owner === currentTurn) {
          moves.push({from: pointIndex, to: dest, die});
        } else if (board[dest].count === 1) {
          moves.push({from: pointIndex, to: dest, die, hit: true});
        }
      }
      return moves;
    }

    // Get legal re-entry moves from the bar.
    function getLegalMovesFromBar() {
      let moves = [];
      if (bar[currentTurn] <= 0) return moves;
      for (let die of currentDice) {
        let dest;
        if (currentTurn === 'w') {
          dest = 24 - die;  // For white, if die=1 → index 23; if die=6 → index 18.
        } else {
          dest = die - 1;   // For black, if die=1 → index 0; if die=6 → index 5.
        }
        if (dest < 0 || dest > 23) continue;
        if (!board[dest]) {
          moves.push({from: "bar", to: dest, die});
        } else if (board[dest].owner === currentTurn) {
          moves.push({from: "bar", to: dest, die});
        } else if (board[dest].count === 1) {
          moves.push({from: "bar", to: dest, die, hit: true});
        }
      }
      return moves;
    }

    // Execute a move and update the board state.
    function makeMove(move) {
      try {
        if (move.from === "bar") {
          bar[currentTurn]--;
        } else {
          if (board[move.from]) {
            board[move.from].count--;
            if (board[move.from].count === 0) board[move.from] = null;
          } else {
            logBug("makeMove", "No checker at source " + move.from);
          }
        }
        if (move.bearOff) {
          borneOff[currentTurn]++;
        } else {
          if (move.hit) {
            if (board[move.to] && board[move.to].owner !== currentTurn && board[move.to].count === 1) {
              bar[ board[move.to].owner ]++;
              board[move.to] = { owner: currentTurn, count: 1 };
            }
          } else {
            if (!board[move.to]) {
              board[move.to] = { owner: currentTurn, count: 1 };
            } else if (board[move.to].owner === currentTurn) {
              board[move.to].count++;
            }
          }
        }
        const index = currentDice.indexOf(move.die);
        if (index !== -1) {
          currentDice.splice(index, 1);
        }
        selectedPoint = null;
        legalMoves = [];
      } catch (err) {
        logBug("makeMove", err);
      }
    }

    // Check if a player has borne off all 15 checkers.
    function checkGameOver() {
      if (borneOff['w'] >= 15) {
        gameState = "game_over";
        gameOverText.textContent = "Game Over: White wins!";
        showGameOver();
        return true;
      } else if (borneOff['b'] >= 15) {
        gameState = "game_over";
        gameOverText.textContent = "Game Over: Black wins!";
        showGameOver();
        return true;
      }
      return false;
    }

    /************ Input Handling ************/
    canvas.addEventListener("mousedown", (e) => {
      try {
        if (gameState !== "playing" || aiThinking) return;
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        let clickedPoint = getPointFromCoordinates(mx, my);
        // If there are checkers on the bar, enforce re-entry.
        if (bar[currentTurn] > 0) {
          let reEntryMoves = getLegalMovesFromBar();
          if (reEntryMoves.length === 0) return;
          const move = reEntryMoves.find(m => m.to === clickedPoint);
          if (move) {
            makeMove(move);
            redrawGame();
            if (currentDice.length === 0) endTurn();
          }
          return;
        }
        if (clickedPoint === null) return;
        if (selectedPoint === null) {
          if (board[clickedPoint] && board[clickedPoint].owner === currentTurn) {
            const moves = getLegalMoves(clickedPoint);
            if (moves.length > 0) {
              selectedPoint = clickedPoint;
              legalMoves = moves;
            }
          }
        } else {
          const move = legalMoves.find(m => m.to === clickedPoint);
          if (move) {
            makeMove(move);
            redrawGame();
            if (!checkGameOver() && currentDice.length === 0) endTurn();
          } else {
            selectedPoint = null;
            legalMoves = [];
          }
        }
        redrawGame();
      } catch (err) {
        logBug("canvas mousedown", err);
      }
    });

    // Given canvas coordinates, determine which board point (0–23) was clicked.
    function getPointFromCoordinates(x, y) {
      try {
        const boardMargin = 20;
        const boardWidth = WIDTH - 2 * boardMargin;
        const boardTop = 100;
        const boardHeight = 600;
        if (y < boardTop || y > boardTop + boardHeight) return null;
        const barWidth = 24;
        const pointWidth = (boardWidth - barWidth) / 12;
        let isTop = y < boardTop + boardHeight / 2;
        let pointIndex;
        if (isTop) {
          if (x < boardMargin || x > boardMargin + boardWidth) return null;
          if (x < boardMargin + boardWidth/2 - barWidth/2) {
            let pos = Math.floor((boardMargin + boardWidth/2 - barWidth/2 - x) / pointWidth);
            pointIndex = 23 - pos;
          } else if (x > boardMargin + boardWidth/2 + barWidth/2) {
            let pos = Math.floor((x - (boardMargin + boardWidth/2 + barWidth/2)) / pointWidth);
            pointIndex = 12 + pos;
          } else {
            return null;
          }
        } else {
          if (x < boardMargin || x > boardMargin + boardWidth) return null;
          if (x < boardMargin + boardWidth/2 - barWidth/2) {
            let pos = Math.floor((x - boardMargin) / pointWidth);
            pointIndex = pos;
          } else if (x > boardMargin + boardWidth/2 + barWidth/2) {
            let pos = Math.floor((boardMargin + boardWidth - x) / pointWidth);
            pointIndex = 11 - pos;
          } else {
            return null;
          }
        }
        return pointIndex;
      } catch (err) {
        logBug("getPointFromCoordinates", err);
        return null;
      }
    }

    // End turn by switching current turn and trigger AI if needed.
    function endTurn() {
      currentTurn = (currentTurn === 'w') ? 'b' : 'w';
      if (!checkGameOver()) {
        if (currentTurn !== playerColor) {
          aiTurn();
        } else {
          rollDiceBtn.style.display = "block";
        }
      }
    }

    // Basic AI: Roll dice, compile legal moves (including re-entry), and choose one at random.
    function aiTurn() {
      aiThinking = true;
      loadingOverlay.style.display = "flex";
      setTimeout(() => {
        currentDice = rollDice();
        let possibleMoves = [];
        if (bar[currentTurn] > 0) {
          possibleMoves = getLegalMovesFromBar();
        } else {
          for (let i = 0; i < 24; i++) {
            if (board[i] && board[i].owner === currentTurn) {
              let moves = getLegalMoves(i);
              if (moves.length > 0) {
                possibleMoves = possibleMoves.concat(moves);
              }
            }
          }
        }
        if (possibleMoves.length > 0) {
          let move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
          makeMove(move);
        }
        aiThinking = false;
        loadingOverlay.style.display = "none";
        if (currentDice.length === 0) {
          currentTurn = (currentTurn === 'w') ? 'b' : 'w';
          if (currentTurn === playerColor) {
            rollDiceBtn.style.display = "block";
          } else {
            aiTurn();
          }
        }
        redrawGame();
      }, (difficulty === "hard" ? 1000 : 1500));
    }

    rollDiceBtn.onclick = function() {
      if (currentDice.length === 0) {
        currentDice = rollDice();
        rollDiceBtn.style.display = "none";
        redrawGame();
      }
    };

    /************ Overlay & Menu Management ************/
    function hideAllScreens() {
      menuScreen.style.display = "none";
      instructionsScreen.style.display = "none";
      colorScreen.style.display = "none";
      difficultyScreen.style.display = "none";
      gameOverScreen.style.display = "none";
    }
    function showMenu() {
      hideAllScreens();
      gameState = "menu";
      menuScreen.style.display = "flex";
    }
    function showInstructions() {
      hideAllScreens();
      gameState = "instructions";
      instructionsScreen.style.display = "flex";
    }
    function showColorChoice() {
      hideAllScreens();
      gameState = "color_choice";
      colorScreen.style.display = "flex";
    }
    function showDifficultyChoice() {
      hideAllScreens();
      gameState = "difficulty_choice";
      difficultyScreen.style.display = "flex";
    }
    function startGame() {
      hideAllScreens();
      gameState = "playing";
      initBoard();
      redrawGame();
      if (currentTurn === playerColor) {
        rollDiceBtn.style.display = "block";
      } else {
        rollDiceBtn.style.display = "none";
        aiTurn();
      }
    }
    function showGameOver() {
      hideAllScreens();
      gameState = "game_over";
      gameOverScreen.style.display = "flex";
    }

    document.getElementById("newGameBtn").onclick = function() { showColorChoice(); };
    document.getElementById("instructionsBtn").onclick = function() { showInstructions(); };
    document.getElementById("whiteSideBtn").onclick = function() { playerColor = "w"; showDifficultyChoice(); };
    document.getElementById("blackSideBtn").onclick = function() { playerColor = "b"; showDifficultyChoice(); };
    document.getElementById("easyBtn").onclick = function() { difficulty = "easy"; startGame(); };
    document.getElementById("mediumBtn").onclick = function() { difficulty = "medium"; startGame(); };
    document.getElementById("hardBtn").onclick = function() { difficulty = "hard"; startGame(); };
    document.getElementById("gameOverNewGameBtn").onclick = function() { showColorChoice(); };
    document.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      if (gameState === "color_choice") {
        if (key === "w") document.getElementById("whiteSideBtn").click();
        if (key === "b") document.getElementById("blackSideBtn").click();
      } else if (gameState === "difficulty_choice") {
        if (key === "e") document.getElementById("easyBtn").click();
        if (key === "m") document.getElementById("mediumBtn").click();
        if (key === "h") document.getElementById("hardBtn").click();
      } else if (["playing", "instructions", "game_over"].includes(gameState)) {
        if (key === "m") showMenu();
      }
    });

    /************ Main Loop ************/
    function mainLoop() {
      if (gameState === "playing") {
        redrawGame();
      }
      requestAnimationFrame(mainLoop);
    }
    window.addEventListener("load", () => {
      showMenu();
      mainLoop();
    });
  </script>
</body>
</html>
