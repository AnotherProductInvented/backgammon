<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented Backgammon</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 1rem 0 0.5rem;
      text-align: center;
    }
    /* Main container holds the board and side areas */
    #mainContainer {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
    }
    /* Board container */
    #gameContainer {
      position: relative;
      width: 720px;
      height: 800px;
      background: #f5f5f5;
    }
    /* Side container (for dice and bar) */
    #sideContainer {
      display: flex;
      flex-direction: column;
      margin-left: 20px;
    }
    /* Dice area styles */
    #diceArea {
      text-align: center;
      margin-bottom: 20px;
    }
    #diceCanvas {
      background: #fff;
      border: 2px solid #000;
    }
    /* Bar area styles */
    #barArea {
      text-align: center;
    }
    #barCanvas {
      background: #fff;
      border: 2px solid #000;
      margin-top: 10px;
    }
    /* Overlay screens */
    .overlayScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      background: rgba(255,255,255,0.95);
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      z-index: 5;
    }
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
    }
    /* Loading overlay with spinner */
    #loadingOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      color: #fff;
      font-size: 24px;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 1000;
    }
    .spinner {
      border: 8px solid rgba(255,255,255,0.3);
      border-top: 8px solid #fff;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    /* Logo */
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
  </style>
</head>
<body>
  <!-- Overlay Screens -->
  <div id="menuScreen" class="overlayScreen" style="display: flex;">
    <h1 style="margin:0;">Another Product Invented<br>Backgammon</h1>
    <button id="newGameBtn">New Game</button>
    <button id="instructionsBtn">Instructions</button>
  </div>
  <div id="colorScreen" class="overlayScreen">
    <p>Choose Your Color:</p>
    <button id="whiteSideBtn">White [W]</button>
    <button id="blackSideBtn">Black [B]</button>
    <p>You can also press W or B on your keyboard.</p>
  </div>
  <div id="difficultyScreen" class="overlayScreen">
    <p>Select Difficulty:</p>
    <button id="easyBtn">Easy [E]</button>
    <button id="mediumBtn">Medium [M]</button>
    <button id="hardBtn">Hard [H]</button>
    <p>You can also press E, M, or H on your keyboard.</p>
  </div>
  <div id="instructionsScreen" class="overlayScreen">
    <h2>How to Play Backgammon</h2>
    <p>
      The objective is to move all your checkers to your home board and bear them off.
      On your turn, roll the dice and move your checkers according to the dice values.
      You may hit an opponent's single checker and send it to the bar.
      If you have checkers on the bar, you must re-enter them before making other moves.
      Bear off your checkers once all are in your home board.
    </p>
    <p>Press [M] to return to the Main Menu.</p>
  </div>
  <div id="gameOverScreen" class="overlayScreen">
    <h2 id="gameOverText"></h2>
    <button id="gameOverNewGameBtn">New Game</button>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- Main Container: Board and Side Areas -->
  <div id="mainContainer">
    <!-- Board Container -->
    <div id="gameContainer">
      <canvas id="boardCanvas" width="720" height="800"></canvas>
    </div>
    <!-- Side Container (Dice + Bar) -->
    <div id="sideContainer">
      <div id="diceArea">
        <button id="rollDiceBtn" style="display:none;">Roll Dice</button>
        <br>
        <canvas id="diceCanvas" width="150" height="70"></canvas>
      </div>
      <div id="barArea">
        <h3>Bar</h3>
        <canvas id="barCanvas" width="150" height="200"></canvas>
      </div>
    </div>
  </div>

  <!-- Logo -->
  <img id="logo" src="logo.png" alt="Logo">
  <!-- Loading Overlay -->
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <p>Processing...</p>
  </div>

  <script>
    /************ Bug Detection & Logging ************/
    let bugLogs = [];
    function logBug(location, details) {
      const timestamp = new Date().toISOString();
      const logEntry = { timestamp, location, details };
      bugLogs.push(logEntry);
      console.error("Bug Logged:", logEntry);
    }
    window.onerror = function(message, source, lineno, colno, error) {
      logBug("Global Error", { message, source, lineno, colno, error });
    };

    /************ Global Variables & Constants ************/
    const boardCanvas = document.getElementById("boardCanvas");
    const ctx = boardCanvas.getContext("2d");

    const diceCanvas = document.getElementById("diceCanvas");
    const diceCtx = diceCanvas.getContext("2d");

    const barCanvas = document.getElementById("barCanvas");
    const barCtx = barCanvas.getContext("2d");

    const menuScreen = document.getElementById("menuScreen");
    const instructionsScreen = document.getElementById("instructionsScreen");
    const colorScreen = document.getElementById("colorScreen");
    const difficultyScreen = document.getElementById("difficultyScreen");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const gameOverText = document.getElementById("gameOverText");
    const rollDiceBtn = document.getElementById("rollDiceBtn");
    const loadingOverlay = document.getElementById("loadingOverlay");

    const WIDTH = 720, HEIGHT = 800;
    let gameState = "menu";  // "menu", "instructions", "color_choice", "difficulty_choice", "playing", "game_over"
    let playerColor = null;  // "w" or "b"
    let difficulty = null;   // "easy", "medium", "hard"
    let currentTurn = "w";   // white moves first
    let selectedPoint = null;
    let legalMoves = [];
    let currentDice = [];    // e.g. [3, 5] or [4, 4, 4, 4]
    let aiThinking = false;
    let borneOff = { w: 0, b: 0 };

    // The board is represented as 24 points (indices 0-11 for bottom, 12-23 for top)
    let board = new Array(24).fill(null);
    // The bar is separate:
    let bar = { w: 0, b: 0 };

    /************ Game Initialization ************/
    function initBoard() {
      try {
        board.fill(null);
        borneOff = { w: 0, b: 0 };
        bar = { w: 0, b: 0 };
        // Standard backgammon starting positions
        board[23] = { owner: 'w', count: 2 };  // Point 24
        board[12] = { owner: 'w', count: 5 };  // Point 13
        board[7]  = { owner: 'w', count: 3 };  // Point 8
        board[5]  = { owner: 'w', count: 5 };  // Point 6
        board[0]  = { owner: 'b', count: 2 };  // Point 1
        board[11] = { owner: 'b', count: 5 };  // Point 12
        board[16] = { owner: 'b', count: 3 };  // Point 17
        board[18] = { owner: 'b', count: 5 };  // Point 19
        currentTurn = "w";
        currentDice = [];
        selectedPoint = null;
        legalMoves = [];
      } catch (err) {
        logBug("initBoard", err);
      }
    }

    /************ Dice Rolling & Drawing ************/
    function rollDice() {
      try {
        const die1 = Math.floor(Math.random() * 6) + 1;
        const die2 = Math.floor(Math.random() * 6) + 1;
        if (die1 === die2) {
          return [die1, die1, die1, die1];
        }
        return [die1, die2];
      } catch (err) {
        logBug("rollDice", err);
        return [];
      }
    }

    function drawDiceOnCanvas() {
      diceCtx.clearRect(0, 0, diceCanvas.width, diceCanvas.height);
      if (currentDice.length === 0) return;
      let diceToShow = currentDice.slice(0, 2);
      const diceSize = 60;
      const spacing = 10;
      for (let i = 0; i < diceToShow.length; i++) {
        drawDieOnCanvas(diceCtx, i * (diceSize + spacing), 0, diceSize, diceToShow[i]);
      }
    }

    function drawDieOnCanvas(ctx, x, y, size, value) {
      ctx.fillStyle = "#fff";
      ctx.fillRect(x, y, size, size);
      ctx.strokeStyle = "#000";
      ctx.strokeRect(x, y, size, size);
      ctx.fillStyle = "#000";
      const dotRadius = size / 10;
      const centerX = x + size / 2;
      const centerY = y + size / 2;
      const positions = {
        topLeft: { x: x + size * 0.25, y: y + size * 0.25 },
        topRight: { x: x + size * 0.75, y: y + size * 0.25 },
        middle: { x: centerX, y: centerY },
        bottomLeft: { x: x + size * 0.25, y: y + size * 0.75 },
        bottomRight: { x: x + size * 0.75, y: y + size * 0.75 },
        middleLeft: { x: x + size * 0.25, y: centerY },
        middleRight: { x: x + size * 0.75, y: centerY }
      };
      function drawDot(pos) {
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, dotRadius, 0, Math.PI * 2);
        ctx.fill();
      }
      switch(value) {
        case 1:
          drawDot(positions.middle);
          break;
        case 2:
          drawDot(positions.topLeft);
          drawDot(positions.bottomRight);
          break;
        case 3:
          drawDot(positions.topLeft);
          drawDot(positions.middle);
          drawDot(positions.bottomRight);
          break;
        case 4:
          drawDot(positions.topLeft);
          drawDot(positions.topRight);
          drawDot(positions.bottomLeft);
          drawDot(positions.bottomRight);
          break;
        case 5:
          drawDot(positions.topLeft);
          drawDot(positions.topRight);
          drawDot(positions.middle);
          drawDot(positions.bottomLeft);
          drawDot(positions.bottomRight);
          break;
        case 6:
          drawDot(positions.topLeft);
          drawDot(positions.topRight);
          drawDot(positions.middleLeft);
          drawDot(positions.middleRight);
          drawDot(positions.bottomLeft);
          drawDot(positions.bottomRight);
          break;
      }
    }

    rollDiceBtn.onclick = function() {
      if (currentDice.length === 0) {
        currentDice = rollDice();
        drawDiceOnCanvas();
        rollDiceBtn.style.display = "none";
        redrawGame();
      }
    };

    /************ Board Drawing (Without Integrated Bar) ************/
    // In this version the board is drawn continuously (12 points per half)
    function drawBoard() {
      try {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        // Board parameters
        const boardMargin = 20;
        const boardWidth = WIDTH - 2 * boardMargin;
        const boardHeight = 600;
        const boardTop = 100;
        ctx.fillStyle = "#f5f5f5";
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        // Draw board background (green)
        ctx.fillStyle = "#006400";
        ctx.fillRect(boardMargin, boardTop, boardWidth, boardHeight);
        // Calculate point dimensions (no central bar)
        const pointWidth = boardWidth / 12;
        const pointHeight = boardHeight / 2;
        // Draw top half (points 24 to 13; board indices 23 down to 12)
        for (let i = 0; i < 12; i++) {
          let boardIndex = 23 - i; // so i=0 => point 24, i=11 => point 13
          let tri = getTriangleCoordinates(boardIndex);
          drawTriangle(tri.x, tri.y, tri.width, tri.height, tri.direction, (i % 2 === 0) ? "#deb887" : "#d2b48c");
        }
        // Draw bottom half (points 1 to 12; board indices 0 to 11)
        for (let i = 0; i < 12; i++) {
          let boardIndex = i; 
          let tri = getTriangleCoordinates(boardIndex);
          drawTriangle(tri.x, tri.y, tri.width, tri.height, tri.direction, (i % 2 === 0) ? "#deb887" : "#d2b48c");
        }
      } catch (err) {
        logBug("drawBoard", err);
      }
    }

    // Draw a triangle given its coordinates
    function drawTriangle(x, y, width, height, direction, color) {
      try {
        ctx.fillStyle = color;
        ctx.beginPath();
        if (direction === "up") {
          ctx.moveTo(x, y + height);
          ctx.lineTo(x + width / 2, y);
          ctx.lineTo(x + width, y + height);
        } else {
          ctx.moveTo(x, y);
          ctx.lineTo(x + width / 2, y + height);
          ctx.lineTo(x + width, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
      } catch (err) {
        logBug("drawTriangle", err);
      }
    }

    // Given a board point index (0â€“23), return the coordinates of its triangle.
    function getTriangleCoordinates(pointIndex) {
      const boardMargin = 20;
      const boardWidth = WIDTH - 2 * boardMargin;
      const boardTop = 100;
      const boardHeight = 600;
      const pointWidth = boardWidth / 12;
      const pointHeight = boardHeight / 2;
      let x, y, direction;
      if (pointIndex >= 12 && pointIndex <= 23) {
        // Top half: points 24 (index 23) to 13 (index 12)
        let indexInHalf = 23 - pointIndex; // 0 for point 24, 11 for point 13
        x = boardMargin + indexInHalf * pointWidth;
        y = boardTop;
        direction = "down";
      } else if (pointIndex >= 0 && pointIndex <= 11) {
        // Bottom half: points 1 (index 0) to 12 (index 11)
        let indexInHalf = pointIndex;
        x = boardMargin + indexInHalf * pointWidth;
        y = boardTop + boardHeight - pointHeight;
        direction = "up";
      } else {
        return null;
      }
      return { x, y, width: pointWidth, height: pointHeight, direction };
    }

    /************ Pieces Drawing ************/
    function drawPieces() {
      try {
        const boardMargin = 20;
        const boardWidth = WIDTH - 2 * boardMargin;
        const boardTop = 100;
        const boardHeight = 600;
        const pointWidth = boardWidth / 12;
        const pointHeight = boardHeight / 2;
        let pieceRadius = Math.min(pointWidth, pointHeight) / 4;
        ctx.font = "20px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (let i = 0; i < 24; i++) {
          if (!board[i]) continue;
          let tri = getTriangleCoordinates(i);
          let centerX = tri.x + tri.width / 2;
          let spacing = pieceRadius * 2.2;
          // For top half, stack downward; bottom half, stack upward.
          for (let j = 0; j < board[i].count; j++) {
            let centerY;
            if (i >= 12) {
              centerY = boardTop + pieceRadius + j * spacing;
            } else {
              centerY = boardTop + boardHeight - pieceRadius - j * spacing;
            }
            ctx.beginPath();
            ctx.arc(centerX, centerY, pieceRadius, 0, Math.PI * 2);
            ctx.fillStyle = (board[i].owner === 'w') ? "#fff" : "#000";
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.stroke();
          }
          if (board[i].count > 5) {
            ctx.fillStyle = "red";
            ctx.fillText(board[i].count, centerX, (i >= 12) ? boardTop + pieceRadius + 5 * spacing : boardTop + boardHeight - pieceRadius - 5 * spacing);
          }
        }
        // Display borne-off counts (drawn on the board)
        ctx.fillStyle = "#000";
        ctx.fillText("White Borne Off: " + borneOff.w, WIDTH - 150, boardTop + boardHeight + 30);
        ctx.fillText("Black Borne Off: " + borneOff.b, WIDTH - 150, boardTop - 30);
      } catch (err) {
        logBug("drawPieces", err);
      }
    }

    /************ Bar Area Drawing ************/
    function drawBarPieces() {
      try {
        barCtx.clearRect(0, 0, barCanvas.width, barCanvas.height);
        barCtx.font = "16px sans-serif";
        barCtx.fillStyle = "#000";
        barCtx.fillText("Bar", barCanvas.width/2, 20);
        const pieceRadius = 15;
        const spacing = pieceRadius * 2.2;
        // Draw white bar pieces on the top half of bar area
        for (let j = 0; j < bar.w; j++) {
          let centerX = barCanvas.width / 2;
          let centerY = 40 + j * spacing;
          barCtx.beginPath();
          barCtx.arc(centerX, centerY, pieceRadius, 0, Math.PI*2);
          barCtx.fillStyle = "#fff";
          barCtx.fill();
          barCtx.strokeStyle = "#000";
          barCtx.stroke();
        }
        // Draw black bar pieces on the bottom half of bar area
        for (let j = 0; j < bar.b; j++) {
          let centerX = barCanvas.width / 2;
          let centerY = barCanvas.height - 40 - j * spacing;
          barCtx.beginPath();
          barCtx.arc(centerX, centerY, pieceRadius, 0, Math.PI*2);
          barCtx.fillStyle = "#000";
          barCtx.fill();
          barCtx.strokeStyle = "#000";
          barCtx.stroke();
        }
      } catch (err) {
        logBug("drawBarPieces", err);
      }
    }

    /************ Highlighting Selected Piece & Legal Moves ************/
    function highlightLegalOptions() {
      if (selectedPoint !== null) {
        const selCoords = getTriangleCoordinates(selectedPoint);
        if (selCoords) {
          ctx.fillStyle = "rgba(0,255,255,0.5)"; // Cyan for selected
          ctx.fillRect(selCoords.x, selCoords.y, selCoords.width, selCoords.height);
        }
        legalMoves.forEach(move => {
          // For bear-off moves, you might highlight a dedicated off-board area (not implemented here)
          if (!move.bearOff) {
            const destCoords = getTriangleCoordinates(move.to);
            if (destCoords) {
              ctx.fillStyle = "rgba(255,255,0,0.5)"; // Yellow for legal destination
              ctx.fillRect(destCoords.x, destCoords.y, destCoords.width, destCoords.height);
            }
          }
        });
      }
    }

    /************ Redraw Everything ************/
    function redrawGame() {
      try {
        drawBoard();
        highlightLegalOptions();
        drawPieces();
        drawDiceOnCanvas();
        drawBarPieces();
      } catch (err) {
        logBug("redrawGame", err);
      }
    }

    /************ Move Logic ************/
    function canBearOff(color) {
      let inHome = true;
      for (let i = 0; i < 24; i++) {
        if (board[i] && board[i].owner === color) {
          if (color === 'w' && i > 5) { inHome = false; }
          if (color === 'b' && i < 18) { inHome = false; }
        }
      }
      if (bar[color] > 0) inHome = false;
      return inHome;
    }

    function getLegalMoves(pointIndex) {
      let moves = [];
      if (!board[pointIndex] || board[pointIndex].owner !== currentTurn) return moves;
      for (let die of currentDice) {
        let dest;
        if (currentTurn === 'w') {
          dest = pointIndex - die;
          if (dest < 0 && canBearOff('w')) {
            moves.push({from: pointIndex, to: -1, die, bearOff: true});
            continue;
          }
        } else {
          dest = pointIndex + die;
          if (dest > 23 && canBearOff('b')) {
            moves.push({from: pointIndex, to: 24, die, bearOff: true});
            continue;
          }
        }
        if (dest < 0 || dest > 23) continue;
        if (!board[dest]) {
          moves.push({from: pointIndex, to: dest, die});
        } else if (board[dest].owner === currentTurn) {
          moves.push({from: pointIndex, to: dest, die});
        } else if (board[dest].count === 1) {
          moves.push({from: pointIndex, to: dest, die, hit: true});
        }
      }
      return moves;
    }

    function getLegalMovesFromBar() {
      let moves = [];
      if (bar[currentTurn] <= 0) return moves;
      for (let die of currentDice) {
        let dest;
        if (currentTurn === 'w') {
          dest = 24 - die;
        } else {
          dest = die - 1;
        }
        if (dest < 0 || dest > 23) continue;
        if (!board[dest]) {
          moves.push({from: "bar", to: dest, die});
        } else if (board[dest].owner === currentTurn) {
          moves.push({from: "bar", to: dest, die});
        } else if (board[dest].count === 1) {
          moves.push({from: "bar", to: dest, die, hit: true});
        }
      }
      return moves;
    }

    function makeMove(move) {
      try {
        if (move.from === "bar") {
          bar[currentTurn]--;
        } else {
          if (board[move.from]) {
            board[move.from].count--;
            if (board[move.from].count === 0) board[move.from] = null;
          } else {
            logBug("makeMove", "No checker at source " + move.from);
          }
        }
        if (move.bearOff) {
          borneOff[currentTurn]++;
        } else {
          if (move.hit) {
            if (board[move.to] && board[move.to].owner !== currentTurn && board[move.to].count === 1) {
              bar[ board[move.to].owner ]++;
              board[move.to] = { owner: currentTurn, count: 1 };
            }
          } else {
            if (!board[move.to]) {
              board[move.to] = { owner: currentTurn, count: 1 };
            } else if (board[move.to].owner === currentTurn) {
              board[move.to].count++;
            }
          }
        }
        const index = currentDice.indexOf(move.die);
        if (index !== -1) {
          currentDice.splice(index, 1);
        }
        selectedPoint = null;
        legalMoves = [];
      } catch (err) {
        logBug("makeMove", err);
      }
    }

    function checkGameOver() {
      if (borneOff['w'] >= 15) {
        gameState = "game_over";
        gameOverText.textContent = "Game Over: White wins!";
        showGameOver();
        return true;
      } else if (borneOff['b'] >= 15) {
        gameState = "game_over";
        gameOverText.textContent = "Game Over: Black wins!";
        showGameOver();
        return true;
      }
      return false;
    }

    /************ Input Handling ************/
    boardCanvas.addEventListener("mousedown", (e) => {
      try {
        if (gameState !== "playing" || aiThinking) return;
        const rect = boardCanvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        let clickedPoint = getPointFromCoordinates(mx, my);
        // Enforce re-entry if checkers are on the bar.
        if (bar[currentTurn] > 0) {
          let reEntryMoves = getLegalMovesFromBar();
          if (reEntryMoves.length === 0) return;
          const move = reEntryMoves.find(m => m.to === clickedPoint);
          if (move) {
            makeMove(move);
            redrawGame();
            if (currentDice.length === 0) endTurn();
          }
          return;
        }
        if (clickedPoint === null) return;
        if (selectedPoint === null) {
          if (board[clickedPoint] && board[clickedPoint].owner === currentTurn) {
            const moves = getLegalMoves(clickedPoint);
            if (moves.length > 0) {
              selectedPoint = clickedPoint;
              legalMoves = moves;
            }
          }
        } else {
          const move = legalMoves.find(m => m.to === clickedPoint);
          if (move) {
            makeMove(move);
            redrawGame();
            if (!checkGameOver() && currentDice.length === 0) endTurn();
          } else {
            selectedPoint = null;
            legalMoves = [];
          }
        }
        redrawGame();
      } catch (err) {
        logBug("boardCanvas mousedown", err);
      }
    });

    // Given (x,y) in board canvas, determine which board point was clicked.
    function getPointFromCoordinates(x, y) {
      try {
        const boardMargin = 20;
        const boardWidth = WIDTH - 2 * boardMargin;
        const boardTop = 100;
        const boardHeight = 600;
        if (y < boardTop || y > boardTop + boardHeight) return null;
        const pointWidth = boardWidth / 12;
        let isTop = y < boardTop + boardHeight / 2;
        let pointIndex;
        if (isTop) {
          // Top half: x goes left to right corresponds to points 24 to 13
          let pos = Math.floor((x - boardMargin) / pointWidth);
          pointIndex = 23 - pos;
        } else {
          // Bottom half: x goes left to right corresponds to points 1 to 12
          let pos = Math.floor((x - boardMargin) / pointWidth);
          pointIndex = pos;
        }
        return pointIndex;
      } catch (err) {
        logBug("getPointFromCoordinates", err);
        return null;
      }
    }

    function endTurn() {
      currentTurn = (currentTurn === 'w') ? 'b' : 'w';
      if (!checkGameOver()) {
        if (currentTurn !== playerColor) {
          aiTurn();
        } else {
          rollDiceBtn.style.display = "block";
        }
      }
    }

    function aiTurn() {
      aiThinking = true;
      loadingOverlay.style.display = "flex";
      setTimeout(() => {
        currentDice = rollDice();
        let possibleMoves = [];
        if (bar[currentTurn] > 0) {
          possibleMoves = getLegalMovesFromBar();
        } else {
          for (let i = 0; i < 24; i++) {
            if (board[i] && board[i].owner === currentTurn) {
              let moves = getLegalMoves(i);
              if (moves.length > 0) {
                possibleMoves = possibleMoves.concat(moves);
              }
            }
          }
        }
        if (possibleMoves.length > 0) {
          let move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
          makeMove(move);
        }
        aiThinking = false;
        loadingOverlay.style.display = "none";
        if (currentDice.length === 0) {
          currentTurn = (currentTurn === 'w') ? 'b' : 'w';
          if (currentTurn === playerColor) {
            rollDiceBtn.style.display = "block";
          } else {
            aiTurn();
          }
        }
        redrawGame();
      }, (difficulty === "hard" ? 1000 : 1500));
    }

    /************ Overlay & Menu Management ************/
    function hideAllScreens() {
      menuScreen.style.display = "none";
      instructionsScreen.style.display = "none";
      colorScreen.style.display = "none";
      difficultyScreen.style.display = "none";
      gameOverScreen.style.display = "none";
    }
    function showMenu() {
      hideAllScreens();
      gameState = "menu";
      menuScreen.style.display = "flex";
    }
    function showInstructions() {
      hideAllScreens();
      gameState = "instructions";
      instructionsScreen.style.display = "flex";
    }
    function showColorChoice() {
      hideAllScreens();
      gameState = "color_choice";
      colorScreen.style.display = "flex";
    }
    function showDifficultyChoice() {
      hideAllScreens();
      gameState = "difficulty_choice";
      difficultyScreen.style.display = "flex";
    }
    function startGame() {
      hideAllScreens();
      gameState = "playing";
      initBoard();
      redrawGame();
      if (currentTurn === playerColor) {
        rollDiceBtn.style.display = "block";
      } else {
        rollDiceBtn.style.display = "none";
        aiTurn();
      }
    }
    function showGameOver() {
      hideAllScreens();
      gameState = "game_over";
      gameOverScreen.style.display = "flex";
    }

    document.getElementById("newGameBtn").onclick = function() { showColorChoice(); };
    document.getElementById("instructionsBtn").onclick = function() { showInstructions(); };
    document.getElementById("whiteSideBtn").onclick = function() { playerColor = "w"; showDifficultyChoice(); };
    document.getElementById("blackSideBtn").onclick = function() { playerColor = "b"; showDifficultyChoice(); };
    document.getElementById("easyBtn").onclick = function() { difficulty = "easy"; startGame(); };
    document.getElementById("mediumBtn").onclick = function() { difficulty = "medium"; startGame(); };
    document.getElementById("hardBtn").onclick = function() { difficulty = "hard"; startGame(); };
    document.getElementById("gameOverNewGameBtn").onclick = function() { showColorChoice(); };
    document.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      if (gameState === "color_choice") {
        if (key === "w") document.getElementById("whiteSideBtn").click();
        if (key === "b") document.getElementById("blackSideBtn").click();
      } else if (gameState === "difficulty_choice") {
        if (key === "e") document.getElementById("easyBtn").click();
        if (key === "m") document.getElementById("mediumBtn").click();
        if (key === "h") document.getElementById("hardBtn").click();
      } else if (["playing", "instructions", "game_over"].includes(gameState)) {
        if (key === "m") showMenu();
      }
    });

    /************ Main Loop ************/
    function mainLoop() {
      if (gameState === "playing") {
        redrawGame();
      }
      requestAnimationFrame(mainLoop);
    }
    window.addEventListener("load", () => {
      showMenu();
      mainLoop();
    });
  </script>
</body>
</html>
