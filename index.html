<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Backgammon Game – Basic Movement</title>
  <style>
    body {
      background: #eee;
      margin: 0;
      padding: 20px;
      font-family: sans-serif;
      text-align: center;
    }
    h1 { margin-bottom: 20px; }
    canvas {
      border: 2px solid #000;
      background: #fff;
      margin-bottom: 20px;
    }
    button {
      font-size: 20px;
      padding: 10px 20px;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <h1>Backgammon Game</h1>
  <!-- Backgammon Board Canvas -->
  <canvas id="boardCanvas" width="720" height="800"></canvas>
  <!-- Dice Roll Section -->
  <h1>Roll the Dice!</h1>
  <canvas id="diceCanvas" width="300" height="150"></canvas>
  <button id="rollBtn">Roll Dice</button>
  <p id="diceResult"></p>
  <script>
    /*****************************************************
     * Global Constants and Variables
     *****************************************************/
    const boardCanvas = document.getElementById("boardCanvas");
    const ctx = boardCanvas.getContext("2d");
    const diceCanvas = document.getElementById("diceCanvas");
    const diceCtx = diceCanvas.getContext("2d");
    const rollBtn = document.getElementById("rollBtn");
    const diceResultP = document.getElementById("diceResult");

    // Board dimensions and layout:
    const WIDTH = boardCanvas.width;  // 720
    const HEIGHT = boardCanvas.height; // 800
    const boardMargin = 20;
    const barWidth = 40;
    // Reserve zones: top 150px for White's bear‑off; bottom 100px for Black's.
    const bearOffTop = 150; 
    const bearOffBottom = 100;
    const boardTop = bearOffTop; 
    const boardHeight = HEIGHT - bearOffTop - bearOffBottom;
    // The board area (excluding the central bar) is split into 12 points per half.
    const boardWidth = WIDTH - 2 * boardMargin - barWidth;
    const pointWidth = boardWidth / 12;

    // Colors for players
    const whiteColor = "#fff";
    const blackColor = "#000";

    // Board state: an array of 24 points (0–11: bottom row [points 1–12], 12–23: top row [points 13–24])
    // Standard starting positions:
    // White: 2 on point 24 (index 23), 5 on point 13 (index 12), 3 on point 8 (index 7), 5 on point 6 (index 5)
    // Black: 2 on point 1 (index 0), 5 on point 12 (index 11), 3 on point 17 (index 16), 5 on point 19 (index 18)
    let board = new Array(24).fill(null);
    board[23] = { owner: 'w', count: 2 };
    board[12] = { owner: 'w', count: 5 };
    board[7]  = { owner: 'w', count: 3 };
    board[5]  = { owner: 'w', count: 5 };

    board[0]  = { owner: 'b', count: 2 };
    board[11] = { owner: 'b', count: 5 };
    board[16] = { owner: 'b', count: 3 };
    board[18] = { owner: 'b', count: 5 };

    // For now we won’t use the bar or borne-off areas (movement later)
    let bar = { w: 0, b: 0 };
    let borneOff = { w: 0, b: 0 };

    // Variables for movement (selected piece, legal moves, current dice)
    let selectedPoint = null;
    let legalMoves = [];
    let currentDice = [];

    // Turn control: For simplicity, assume human plays white; black will be "computer"
    let currentTurn = "w";

    // For dice animation
    const diceAnimationDuration = 1000;

    /*****************************************************
     * Drawing Functions (Board, Triangles, Pieces)
     *****************************************************/
    function drawBoard() {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      
      // Draw White Bear-Off Zone (top)
      ctx.fillStyle = "#e0e0e0";
      ctx.fillRect(boardMargin, 20, WIDTH - 2 * boardMargin, bearOffTop - 20);
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 3;
      ctx.strokeRect(boardMargin, 20, WIDTH - 2 * boardMargin, bearOffTop - 20);
      ctx.font = "18px sans-serif";
      ctx.fillStyle = "blue";
      ctx.textAlign = "center";
      ctx.fillText("White Bear Off", WIDTH / 2, 40);

      // Draw Black Bear-Off Zone (bottom)
      ctx.fillStyle = "#e0e0e0";
      ctx.fillRect(boardMargin, boardTop + boardHeight + 20, WIDTH - 2 * boardMargin, bearOffBottom - 20);
      ctx.strokeStyle = "blue";
      ctx.strokeRect(boardMargin, boardTop + boardHeight + 20, WIDTH - 2 * boardMargin, bearOffBottom - 20);
      ctx.fillStyle = "blue";
      ctx.fillText("Black Bear Off", WIDTH / 2, boardTop + boardHeight + 40);

      // Draw main board background
      ctx.fillStyle = "#f5f5f5";
      ctx.fillRect(0, boardTop, WIDTH, boardHeight);

      // Draw board area (with a green background) for the two halves
      // Left half (points 1–6 and 19–24)
      ctx.fillStyle = "#006400";
      ctx.fillRect(boardMargin, boardTop, boardWidth / 2, boardHeight);
      // Right half (points 7–12 and 13–18)
      ctx.fillRect(boardMargin + boardWidth / 2 + barWidth, boardTop, boardWidth / 2, boardHeight);

      // Draw the central bar
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(boardMargin + boardWidth / 2, boardTop, barWidth, boardHeight);

      // Draw triangles for bottom row (points 1–12; indices 0–11) – drawn right-to-left
      for (let p = 1; p <= 12; p++) {
        let pos = 12 - p;
        let x = boardMargin + pos * pointWidth;
        let y = boardTop + boardHeight - boardHeight / 2;
        let direction = "up";
        let color = (p % 2 === 0) ? "#deb887" : "#d2b48c";
        drawTriangle(x, y, pointWidth, boardHeight / 2, direction, color);
      }

      // Draw triangles for top row (points 13–24; indices 12–23) – drawn left-to-right
      for (let p = 13; p <= 24; p++) {
        let idx = p - 13;
        let x = boardMargin + idx * pointWidth;
        let y = boardTop;
        let direction = "down";
        let color = (p % 2 === 0) ? "#deb887" : "#d2b48c";
        drawTriangle(x, y, pointWidth, boardHeight / 2, direction, color);
      }

      // Draw borne-off pieces (for now they remain static)
      drawBearOffPieces();
    }

    function drawTriangle(x, y, width, height, direction, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      if (direction === "up") {
        ctx.moveTo(x, y + height);
        ctx.lineTo(x + width / 2, y);
        ctx.lineTo(x + width, y + height);
      } else { // "down"
        ctx.moveTo(x, y);
        ctx.lineTo(x + width / 2, y + height);
        ctx.lineTo(x + width, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.stroke();
    }

    // Calculate the coordinates of the triangle for a given point index
    function getTriangleCoordinates(idx) {
      let x, y, width = pointWidth, height;
      if (idx >= 12 && idx <= 23) {
        // Top row: points 13-24, drawn left-to-right.
        let p = idx + 1;
        x = boardMargin + (p - 13) * pointWidth;
        y = boardTop;
        height = boardHeight / 2;
        return { x, y, width, height };
      } else if (idx >= 0 && idx <= 11) {
        // Bottom row: points 1-12, drawn right-to-left.
        let p = idx + 1;
        let pos = 12 - p;
        x = boardMargin + pos * pointWidth;
        y = boardTop + boardHeight / 2;
        height = boardHeight / 2;
        return { x, y, width, height };
      }
      return null;
    }

    // Draw borne-off pieces in the integrated zones
    function drawBearOffPieces() {
      const pieceRadius = 15, spacing = pieceRadius * 2.2;
      // White borne-off pieces: drawn in top zone (along bottom edge)
      for (let i = 0; i < borneOff.w; i++) {
        let cx = boardMargin + 30 + i * spacing;
        let cy = boardTop - 30;
        drawChecker(cx, cy, pieceRadius, 'w');
      }
      // Black borne-off pieces: drawn in bottom zone (along top edge)
      for (let i = 0; i < borneOff.b; i++) {
        let cx = boardMargin + 30 + i * spacing;
        let cy = boardTop + boardHeight + 50;
        drawChecker(cx, cy, pieceRadius, 'b');
      }
    }

    // Draw a single checker (circle)
    function drawChecker(cx, cy, radius, owner) {
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
      ctx.fillStyle = owner === 'w' ? whiteColor : blackColor;
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.stroke();
    }

    // Redraw the board and pieces
    function redrawBoard() {
      drawBoard();
      drawPieces();
    }

    // Draw pieces on board (stacked inside triangles)
    function drawPieces() {
      for (let i = 0; i < 24; i++) {
        if (!board[i]) continue;
        let tri = getTriangleCoordinates(i);
        let centerX = tri.x + tri.width / 2;
        // Use a spacing based on triangle height
        let spacing = Math.min(tri.width, tri.height) / 3;
        for (let j = 0; j < board[i].count; j++) {
          let centerY;
          if (i < 12) {
            // Bottom row: stack from bottom up
            centerY = tri.y + tri.height - (j + 0.5) * spacing;
          } else {
            // Top row: stack from top down
            centerY = tri.y + (j + 0.5) * spacing;
          }
          drawChecker(centerX, centerY, 15, board[i].owner);
        }
      }
    }

    /*****************************************************
     * Dice Functions & Animation
     *****************************************************/
    function rollDiceSimple() {
      return [Math.floor(Math.random() * 6) + 1, Math.floor(Math.random() * 6) + 1];
    }

    function drawDice(dice) {
      diceCtx.clearRect(0, 0, diceCanvas.width, diceCanvas.height);
      const dieSize = 100;
      drawDie(20, 25, dieSize, dice[0]);
      drawDie(150, 25, dieSize, dice[1]);
      diceResultP.textContent = `Result: ${dice[0]} and ${dice[1]}`;
    }

    function drawDie(x, y, size, value) {
      diceCtx.fillStyle = "#fff";
      diceCtx.fillRect(x, y, size, size);
      diceCtx.strokeStyle = "#000";
      diceCtx.strokeRect(x, y, size, size);
      diceCtx.fillStyle = "#000";
      const dotRadius = size / 10;
      const cx = x + size / 2;
      const cy = y + size / 2;
      const dots = {
        1: [{ x: cx, y: cy }],
        2: [{ x: x + size * 0.25, y: y + size * 0.25 }, { x: x + size * 0.75, y: y + size * 0.75 }],
        3: [{ x: x + size * 0.25, y: y + size * 0.25 }, { x: cx, y: cy }, { x: x + size * 0.75, y: y + size * 0.75 }],
        4: [{ x: x + size * 0.25, y: y + size * 0.25 }, { x: x + size * 0.75, y: y + size * 0.25 },
            { x: x + size * 0.25, y: y + size * 0.75 }, { x: x + size * 0.75, y: y + size * 0.75 }],
        5: [{ x: x + size * 0.25, y: y + size * 0.25 }, { x: x + size * 0.75, y: y + size * 0.25 },
            { x: cx, y: cy },
            { x: x + size * 0.25, y: y + size * 0.75 }, { x: x + size * 0.75, y: y + size * 0.75 }],
        6: [{ x: x + size * 0.25, y: y + size * 0.25 }, { x: x + size * 0.75, y: y + size * 0.25 },
            { x: x + size * 0.25, y: y + size * 0.5 }, { x: x + size * 0.75, y: y + size * 0.5 },
            { x: x + size * 0.25, y: y + size * 0.75 }, { x: x + size * 0.75, y: y + size * 0.75 }]
      };
      dots[value].forEach(dot => {
        diceCtx.beginPath();
        diceCtx.arc(dot.x, dot.y, dotRadius, 0, 2 * Math.PI);
        diceCtx.fill();
      });
    }

    function animateDice(finalDice, duration, callback) {
      let startTime = Date.now();
      let interval = setInterval(() => {
        let elapsed = Date.now() - startTime;
        if (elapsed < duration) {
          let randomDice = [Math.floor(Math.random() * 6) + 1, Math.floor(Math.random() * 6) + 1];
          drawDice(randomDice);
        } else {
          clearInterval(interval);
          drawDice(finalDice);
          if (callback) callback();
        }
      }, 100);
    }

    rollBtn.addEventListener("click", () => {
      const finalDice = rollDiceSimple();
      animateDice(finalDice, diceAnimationDuration, () => {
        console.log("Final dice:", finalDice);
        // Save the result for movement decisions.
        currentDice = finalDice;
      });
    });

    /*****************************************************
     * Movement Logic (Basic Selection & Move)
     *****************************************************/
    // For simplicity, this version uses very basic movement:
    // When a user clicks on a point that has a piece (if it’s their turn), the legal moves for that point are highlighted.
    // Then clicking on one of the highlighted destinations moves the piece.
    // (No hit logic, no bearing-off, no re-entry from the bar are fully implemented yet.)

    function getLegalMoves(pointIndex) {
      // Basic rule: A piece can move forward by a die value.
      // White moves from lower-index to higher-index; Black moves from higher-index to lower-index.
      let moves = [];
      if (!board[pointIndex] || board[pointIndex].owner !== currentTurn) return moves;
      currentDice.forEach(die => {
        let dest;
        if (currentTurn === 'w') {
          dest = pointIndex + die;
          if (dest <= 23) {
            // Only allow move if destination is empty or has own pieces
            if (!board[dest] || board[dest].owner === currentTurn) {
              moves.push({ from: pointIndex, to: dest, die });
            }
          }
        } else {
          dest = pointIndex - die;
          if (dest >= 0) {
            if (!board[dest] || board[dest].owner === currentTurn) {
              moves.push({ from: pointIndex, to: dest, die });
            }
          }
        }
      });
      return moves;
    }

    function makeMove(move) {
      // Remove one checker from source and add to destination.
      if (move.from === "bar") {
        bar[currentTurn]--;
      } else {
        if (board[move.from]) {
          board[move.from].count--;
          if (board[move.from].count === 0) board[move.from] = null;
        }
      }
      // For now, we assume destination is empty or friendly.
      if (!board[move.to]) {
        board[move.to] = { owner: currentTurn, count: 1 };
      } else {
        board[move.to].count++;
      }
      // Remove used die from currentDice
      let dieIndex = currentDice.indexOf(move.die);
      if (dieIndex !== -1) {
        currentDice.splice(dieIndex, 1);
      }
      // Clear selection.
      selectedPoint = null;
      legalMoves = [];
    }

    function highlightLegalOptions() {
      if (selectedPoint !== null) {
        let coords = getTriangleCoordinates(selectedPoint);
        if (coords) {
          ctx.fillStyle = "rgba(0,255,255,0.3)";
          ctx.fillRect(coords.x, coords.y, coords.width, coords.height);
        }
        legalMoves.forEach(move => {
          let dest = getTriangleCoordinates(move.to);
          if (dest) {
            ctx.fillStyle = "rgba(255,255,0,0.3)";
            ctx.fillRect(dest.x, dest.y, dest.width, dest.height);
          }
        });
      }
    }

    // Handle click events on boardCanvas
    boardCanvas.addEventListener("mousedown", (e) => {
      // Only allow moves for human (assume human is white)
      if (currentTurn !== "w") return;
      const rect = boardCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      let clicked = getPointFromCoordinates(mx, my);
      if (clicked === null) return;
      // If nothing is selected, and clicked point has a piece, select it and calculate legal moves.
      if (selectedPoint === null) {
        if (board[clicked] && board[clicked].owner === currentTurn) {
          selectedPoint = clicked;
          legalMoves = getLegalMoves(clicked);
        }
      } else {
        // If clicked destination is one of the legal moves, make the move.
        let move = legalMoves.find(m => m.to === clicked);
        if (move) {
          makeMove(move);
          // After moving, clear selection.
          selectedPoint = null;
          legalMoves = [];
        } else {
          // Deselect if clicking elsewhere.
          selectedPoint = null;
          legalMoves = [];
        }
      }
      redrawBoard();
      // Also redraw dice (so they remain visible)
      if (currentDice.length) drawDice(currentDice);
    });

    // Convert canvas coordinates to board point index (0-23)
    function getPointFromCoordinates(x, y) {
      if (y < boardTop || y > boardTop + boardHeight) return null;
      let pt;
      if (y < boardTop + boardHeight/2) {
        // Top row: points 13-24 (left-to-right)
        let pos = Math.floor((x - boardMargin) / pointWidth);
        pt = pos + 13;
      } else {
        // Bottom row: points 1-12 (right-to-left)
        let pos = Math.floor((x - boardMargin) / pointWidth);
        pt = 12 - pos;
      }
      return pt - 1;
    }

    /*****************************************************
     * Main Redraw Function and Loop
     *****************************************************/
    function redraw() {
      redrawBoard();
      highlightLegalOptions();
    }
    redraw(); // initial draw

    /*****************************************************
     * Dice Roll Button and Animation
     *****************************************************/
    rollBtn.addEventListener("click", () => {
      const finalDice = rollDiceSimple();
      animateDice(finalDice, diceAnimationDuration, () => {
        currentDice = finalDice; // set final dice values for movement decisions
        console.log("Final dice:", finalDice);
      });
    });

  </script>
</body>
</html>
