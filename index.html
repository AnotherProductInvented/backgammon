<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented Backgammon</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 { margin: 1rem 0 0.5rem; text-align: center; }
    /* Overlay Screens */
    .overlayScreen {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      background: rgba(255,255,255,0.95);
      align-items: center; justify-content: center;
      flex-direction: column; text-align: center;
      z-index: 5;
    }
    button {
      font-size: 18px; margin: 10px; padding: 10px 20px; cursor: pointer;
    }
    /* Main container with three columns: Bar, Board, Dice */
    #mainContainer {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      margin-top: 60px;
    }
    /* Bar container on the left */
    #barContainer { width: 150px; text-align: center; }
    /* Board container in the center */
    #boardContainer {
      position: relative;
      width: 720px; height: 800px;
      background: #f5f5f5; margin: 0 20px;
    }
    /* Dice container on the right */
    #diceContainer { width: 150px; text-align: center; }
    /* Canvas styling */
    canvas {
      background: #fff;
      border: 2px solid #000;
      display: block;
      margin: 10px auto;
    }
    /* Logo */
    #logo {
      position: fixed;
      bottom: 10px; right: 10px;
      max-width: 100px; z-index: 2000;
    }
  </style>
</head>
<body>
  <!-- Overlay Screens -->
  <div id="menuScreen" class="overlayScreen" style="display: flex;">
    <h1 style="margin:0;">Another Product Invented<br>Backgammon</h1>
    <button id="newGameBtn">New Game</button>
    <button id="instructionsBtn">Instructions</button>
  </div>
  <div id="colorScreen" class="overlayScreen">
    <p>Choose Your Color:</p>
    <button id="whiteSideBtn">White [W]</button>
    <button id="blackSideBtn">Black [B]</button>
    <p>You can also press W or B on your keyboard.</p>
  </div>
  <div id="difficultyScreen" class="overlayScreen">
    <p>Select Difficulty:</p>
    <button id="easyBtn">Easy [E]</button>
    <button id="mediumBtn">Medium [M]</button>
    <button id="hardBtn">Hard [H]</button>
    <p>You can also press E, M, or H on your keyboard.</p>
  </div>
  <div id="instructionsScreen" class="overlayScreen">
    <h2>How to Play Backgammon</h2>
    <p>
      The objective is to move all your checkers to your home board and bear them off.
      On your turn, roll the dice and move your checkers according to the dice values.
      You may hit an opponent's single checker and send it to the bar.
      If you have checkers on the bar, you must re-enter them before making other moves.
      When all checkers are borne off, you win.
    </p>
    <p>Press [M] to return to the Main Menu.</p>
  </div>
  <div id="gameOverScreen" class="overlayScreen">
    <h2 id="gameOverText"></h2>
    <button id="gameOverNewGameBtn">New Game</button>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- Main Container with three columns -->
  <div id="mainContainer">
    <!-- Bar Container (Left) -->
    <div id="barContainer">
      <h3>Bar</h3>
      <canvas id="barCanvas" width="150" height="200"></canvas>
    </div>
    <!-- Board Container (Center) -->
    <div id="boardContainer">
      <canvas id="boardCanvas" width="720" height="800"></canvas>
    </div>
    <!-- Dice Container (Right) -->
    <div id="diceContainer">
      <button id="rollDiceBtn" style="display:none;">Roll Dice</button>
      <canvas id="diceCanvas" width="150" height="70"></canvas>
    </div>
  </div>

  <!-- Logo -->
  <img id="logo" src="logo.png" alt="Logo">

  <script>
    /************ Bug Detection & Logging ************/
    let bugLogs = [];
    function logBug(location, details) {
      const timestamp = new Date().toISOString();
      const logEntry = { timestamp, location, details };
      bugLogs.push(logEntry);
      console.error("Bug Logged:", logEntry);
    }
    window.onerror = function(message, source, lineno, colno, error) {
      logBug("Global Error", { message, source, lineno, colno, error });
    };

    /************ Global Variables & Constants ************/
    const boardCanvas = document.getElementById("boardCanvas");
    const ctx = boardCanvas.getContext("2d");

    const diceCanvas = document.getElementById("diceCanvas");
    const diceCtx = diceCanvas.getContext("2d");

    const barCanvas = document.getElementById("barCanvas");
    const barCtx = barCanvas.getContext("2d");

    const menuScreen = document.getElementById("menuScreen");
    const instructionsScreen = document.getElementById("instructionsScreen");
    const colorScreen = document.getElementById("colorScreen");
    const difficultyScreen = document.getElementById("difficultyScreen");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const gameOverText = document.getElementById("gameOverText");
    const rollDiceBtn = document.getElementById("rollDiceBtn");

    const WIDTH = 720, HEIGHT = 800;
    let gameState = "menu"; // "menu", "instructions", "color_choice", "difficulty_choice", "playing", "game_over"
    let playerColor = null; // "w" or "b"
    let difficulty = null;  // "easy", "medium", "hard"
    let currentTurn = "w";  // white moves first
    let selectedPoint = null;
    let legalMoves = [];
    let currentDice = [];   // e.g. [3,5] or [4,4,4,4]
    let aiThinking = false;
    let borneOff = { w: 0, b: 0 };

    // The board is an array of 24 points (indices 0–11 for bottom, 12–23 for top)
    let board = new Array(24).fill(null);
    // The bar holds hit checkers:
    let bar = { w: 0, b: 0 };

    // Define delays: human moves use a short delay; AI moves use 60% of original delay.
    const humanDelay = 300; // ms for human move highlighting.
    function getAIDelay() {
      if (difficulty === "hard") return 3000 * 0.6; // 1800 ms
      if (difficulty === "medium") return 2500 * 0.6; // 1500 ms
      return 2000 * 0.6; // 1200 ms for easy.
    }

    /************ Helper: Check if any legal move exists for the current player ************/
    function hasLegalMoves() {
      let moves = [];
      if (bar[currentTurn] > 0) {
        moves = getLegalMovesFromBar();
      } else {
        for (let i = 0; i < 24; i++) {
          if (board[i] && board[i].owner === currentTurn) {
            let pieceMoves = getLegalMoves(i);
            if (pieceMoves.length > 0) {
              moves = moves.concat(pieceMoves);
            }
          }
        }
      }
      return moves.length > 0;
    }

    /************ Game Initialization ************/
    function initBoard() {
      try {
        board.fill(null);
        borneOff = { w: 0, b: 0 };
        bar = { w: 0, b: 0 };
        // Standard backgammon starting positions
        board[23] = { owner: 'w', count: 2 };  // Point 24
        board[12] = { owner: 'w', count: 5 };  // Point 13
        board[7]  = { owner: 'w', count: 3 };  // Point 8
        board[5]  = { owner: 'w', count: 5 };  // Point 6
        board[0]  = { owner: 'b', count: 2 };  // Point 1
        board[11] = { owner: 'b', count: 5 };  // Point 12
        board[16] = { owner: 'b', count: 3 };  // Point 17
        board[18] = { owner: 'b', count: 5 };  // Point 19
        currentTurn = "w";
        currentDice = [];
        selectedPoint = null;
        legalMoves = [];
      } catch (err) {
        logBug("initBoard", err);
      }
    }

    /************ Dice Rolling & Drawing ************/
    function rollDice() {
      try {
        const die1 = Math.floor(Math.random() * 6) + 1;
        const die2 = Math.floor(Math.random() * 6) + 1;
        if (die1 === die2) {
          return [die1, die1, die1, die1]; // Four moves for doubles.
        }
        return [die1, die2];
      } catch (err) {
        logBug("rollDice", err);
        return [];
      }
    }

    function drawDiceOnCanvas() {
      diceCtx.clearRect(0, 0, diceCanvas.width, diceCanvas.height);
      if (currentDice.length === 0) return;
      let diceToShow = currentDice.slice(0, 2);
      const diceSize = 60;
      const spacing = 10;
      for (let i = 0; i < diceToShow.length; i++) {
        drawDieOnCanvas(diceCtx, i * (diceSize + spacing), 0, diceSize, diceToShow[i]);
      }
    }

    function drawDieOnCanvas(ctx, x, y, size, value) {
      ctx.fillStyle = "#fff";
      ctx.fillRect(x, y, size, size);
      ctx.strokeStyle = "#000";
      ctx.strokeRect(x, y, size, size);
      ctx.fillStyle = "#000";
      const dotRadius = size / 10;
      const centerX = x + size / 2;
      const centerY = y + size / 2;
      const positions = {
        topLeft: { x: x + size * 0.25, y: y + size * 0.25 },
        topRight: { x: x + size * 0.75, y: y + size * 0.25 },
        middle: { x: centerX, y: centerY },
        bottomLeft: { x: x + size * 0.25, y: y + size * 0.75 },
        bottomRight: { x: x + size * 0.75, y: y + size * 0.75 },
        middleLeft: { x: x + size * 0.25, y: centerY },
        middleRight: { x: x + size * 0.75, y: centerY }
      };
      function drawDot(pos) {
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, dotRadius, 0, Math.PI * 2);
        ctx.fill();
      }
      switch(value) {
        case 1: drawDot(positions.middle); break;
        case 2: drawDot(positions.topLeft); drawDot(positions.bottomRight); break;
        case 3: drawDot(positions.topLeft); drawDot(positions.middle); drawDot(positions.bottomRight); break;
        case 4: drawDot(positions.topLeft); drawDot(positions.topRight); drawDot(positions.bottomLeft); drawDot(positions.bottomRight); break;
        case 5: drawDot(positions.topLeft); drawDot(positions.topRight); drawDot(positions.middle); drawDot(positions.bottomLeft); drawDot(positions.bottomRight); break;
        case 6: drawDot(positions.topLeft); drawDot(positions.topRight); drawDot(positions.middleLeft); drawDot(positions.middleRight); drawDot(positions.bottomLeft); drawDot(positions.bottomRight); break;
      }
    }

    rollDiceBtn.onclick = function() {
      if (currentDice.length === 0 && currentTurn === playerColor) {
        currentDice = rollDice();
        drawDiceOnCanvas();
        rollDiceBtn.style.display = "none";
        redrawGame();
      }
    };

    /************ Board Drawing (Center Area) ************/
    function drawBoard() {
      try {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        const boardMargin = 20;
        const boardWidth = WIDTH - 2 * boardMargin;
        const boardHeight = 600;
        const boardTop = 100;
        ctx.fillStyle = "#f5f5f5";
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = "#006400";
        ctx.fillRect(boardMargin, boardTop, boardWidth, boardHeight);
        const pointWidth = boardWidth / 12;
        const pointHeight = boardHeight / 2;
        // Draw top half (points 24 to 13, indices 23 to 12)
        for (let i = 0; i < 12; i++) {
          let boardIndex = 23 - i;
          let tri = getTriangleCoordinates(boardIndex);
          drawTriangle(tri.x, tri.y, tri.width, tri.height, tri.direction, (i % 2 === 0) ? "#deb887" : "#d2b48c");
        }
        // Draw bottom half (points 1 to 12, indices 0 to 11)
        for (let i = 0; i < 12; i++) {
          let boardIndex = i;
          let tri = getTriangleCoordinates(boardIndex);
          drawTriangle(tri.x, tri.y, tri.width, tri.height, tri.direction, (i % 2 === 0) ? "#deb887" : "#d2b48c");
        }
        // Draw borne-off pieces on designated areas
        drawBorneOff();
      } catch (err) {
        logBug("drawBoard", err);
      }
    }

    function drawTriangle(x, y, width, height, direction, color) {
      try {
        ctx.fillStyle = color;
        ctx.beginPath();
        if (direction === "up") {
          ctx.moveTo(x, y + height);
          ctx.lineTo(x + width / 2, y);
          ctx.lineTo(x + width, y + height);
        } else {
          ctx.moveTo(x, y);
          ctx.lineTo(x + width / 2, y + height);
          ctx.lineTo(x + width, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
      } catch (err) {
        logBug("drawTriangle", err);
      }
    }

    // Given a point index (0–23), return its triangle coordinates.
    function getTriangleCoordinates(pointIndex) {
      const boardMargin = 20;
      const boardWidth = WIDTH - 2 * boardMargin;
      const boardTop = 100;
      const boardHeight = 600;
      const pointWidth = boardWidth / 12;
      const pointHeight = boardHeight / 2;
      let x, y, direction;
      if (pointIndex >= 12 && pointIndex <= 23) {
        let indexInHalf = 23 - pointIndex;
        x = boardMargin + indexInHalf * pointWidth;
        y = boardTop;
        direction = "down";
      } else if (pointIndex >= 0 && pointIndex <= 11) {
        let indexInHalf = pointIndex;
        x = boardMargin + indexInHalf * pointWidth;
        y = boardTop + boardHeight - pointHeight;
        direction = "up";
      } else {
        return null;
      }
      return { x, y, width: pointWidth, height: pointHeight, direction };
    }

    /************ Borne-off Pieces Drawing ************/
    // Draw borne-off pieces in dedicated areas along the board edges.
    function drawBorneOff() {
      const boardTop = 100, boardHeight = 600;
      const pieceRadius = 20;
      // Draw white borne-off pieces on left side (e.g., near x = 10)
      for (let i = 0; i < borneOff.w; i++) {
        let x = 10, y = boardTop + boardHeight - pieceRadius - i * (pieceRadius * 2.2);
        ctx.beginPath();
        ctx.arc(x, y, pieceRadius, 0, Math.PI * 2);
        ctx.fillStyle = "#fff";
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
      }
      // Draw black borne-off pieces on right side (e.g., near x = WIDTH - 10)
      for (let i = 0; i < borneOff.b; i++) {
        let x = WIDTH - 10, y = boardTop + pieceRadius + i * (pieceRadius * 2.2);
        ctx.beginPath();
        ctx.arc(x, y, pieceRadius, 0, Math.PI * 2);
        ctx.fillStyle = "#000";
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
      }
    }

    /************ Pieces Drawing ************/
    function drawPieces() {
      try {
        const boardMargin = 20;
        const boardWidth = WIDTH - 2 * boardMargin;
        const boardTop = 100;
        const boardHeight = 600;
        const pointWidth = boardWidth / 12;
        const pointHeight = boardHeight / 2;
        let pieceRadius = Math.min(pointWidth, pointHeight) / 4;
        ctx.font = "20px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (let i = 0; i < 24; i++) {
          if (!board[i]) continue;
          let tri = getTriangleCoordinates(i);
          let centerX = tri.x + tri.width / 2;
          let spacing = pieceRadius * 2.2;
          for (let j = 0; j < board[i].count; j++) {
            let centerY;
            if (i >= 12) {
              centerY = boardTop + pieceRadius + j * spacing;
            } else {
              centerY = boardTop + boardHeight - pieceRadius - j * spacing;
            }
            ctx.beginPath();
            ctx.arc(centerX, centerY, pieceRadius, 0, Math.PI * 2);
            ctx.fillStyle = (board[i].owner === 'w') ? "#fff" : "#000";
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.stroke();
          }
          if (board[i].count > 5) {
            ctx.fillStyle = "red";
            ctx.fillText(board[i].count, centerX, (i >= 12) ? boardTop + pieceRadius + 5 * spacing : boardTop + boardHeight - pieceRadius - 5 * spacing);
          }
        }
      } catch (err) {
        logBug("drawPieces", err);
      }
    }

    /************ Bar Area Drawing ************/
    function drawBarPieces() {
      try {
        barCtx.clearRect(0, 0, barCanvas.width, barCanvas.height);
        barCtx.font = "16px sans-serif";
        barCtx.fillStyle = "#000";
        barCtx.fillText("Bar", barCanvas.width/2, 20);
        const pieceRadius = 15;
        const spacing = pieceRadius * 2.2;
        // Draw white pieces on top
        for (let j = 0; j < bar.w; j++) {
          let centerX = barCanvas.width / 2;
          let centerY = 40 + j * spacing;
          barCtx.beginPath();
          barCtx.arc(centerX, centerY, pieceRadius, 0, Math.PI*2);
          barCtx.fillStyle = "#fff";
          barCtx.fill();
          barCtx.strokeStyle = "#000";
          barCtx.stroke();
        }
        // Draw black pieces on bottom
        for (let j = 0; j < bar.b; j++) {
          let centerX = barCanvas.width / 2;
          let centerY = barCanvas.height - 40 - j * spacing;
          barCtx.beginPath();
          barCtx.arc(centerX, centerY, pieceRadius, 0, Math.PI*2);
          barCtx.fillStyle = "#000";
          barCtx.fill();
          barCtx.strokeStyle = "#000";
          barCtx.stroke();
        }
      } catch (err) {
        logBug("drawBarPieces", err);
      }
    }

    /************ Highlighting Selected Piece & Legal Moves ************/
    function highlightLegalOptions() {
      if (selectedPoint !== null) {
        if (selectedPoint === "bar") {
          // Optionally highlight bar area (handled in bar canvas)
        } else {
          const selCoords = getTriangleCoordinates(selectedPoint);
          if (selCoords) {
            ctx.fillStyle = "rgba(0,255,255,0.5)";
            ctx.fillRect(selCoords.x, selCoords.y, selCoords.width, selCoords.height);
          }
        }
        legalMoves.forEach(move => {
          if (!move.bearOff) {
            const destCoords = getTriangleCoordinates(move.to);
            if (destCoords) {
              ctx.fillStyle = "rgba(255,255,0,0.5)";
              ctx.fillRect(destCoords.x, destCoords.y, destCoords.width, destCoords.height);
            }
          }
        });
      }
    }

    /************ Redraw Everything ************/
    function redrawGame() {
      try {
        drawBoard();
        highlightLegalOptions();
        drawPieces();
        drawDiceOnCanvas();
        drawBarPieces();
      } catch (err) {
        logBug("redrawGame", err);
      }
    }

    /************ Move Logic ************/
    function canBearOff(color) {
      let inHome = true;
      for (let i = 0; i < 24; i++) {
        if (board[i] && board[i].owner === color) {
          if (color === 'w' && i > 5) { inHome = false; }
          if (color === 'b' && i < 18) { inHome = false; }
        }
      }
      if (bar[color] > 0) inHome = false;
      return inHome;
    }

    function getLegalMoves(pointIndex) {
      let moves = [];
      if (!board[pointIndex] || board[pointIndex].owner !== currentTurn) return moves;
      for (let die of currentDice) {
        let dest;
        if (currentTurn === 'w') {
          dest = pointIndex - die;
          if (dest < 0 && canBearOff('w')) {
            moves.push({from: pointIndex, to: -1, die, bearOff: true});
            continue;
          }
        } else {
          dest = pointIndex + die;
          if (dest > 23 && canBearOff('b')) {
            moves.push({from: pointIndex, to: 24, die, bearOff: true});
            continue;
          }
        }
        if (dest < 0 || dest > 23) continue;
        if (!board[dest]) {
          moves.push({from: pointIndex, to: dest, die});
        } else if (board[dest].owner === currentTurn) {
          moves.push({from: pointIndex, to: dest, die});
        } else if (board[dest].count === 1) {
          moves.push({from: pointIndex, to: dest, die, hit: true});
        }
      }
      return moves;
    }

    function getLegalMovesFromBar() {
      let moves = [];
      if (bar[currentTurn] <= 0) return moves;
      for (let die of currentDice) {
        let dest;
        if (currentTurn === 'w') {
          dest = 24 - die;
        } else {
          dest = die - 1;
        }
        if (dest < 0 || dest > 23) continue;
        if (!board[dest]) {
          moves.push({from: "bar", to: dest, die});
        } else if (board[dest].owner === currentTurn) {
          moves.push({from: "bar", to: dest, die});
        } else if (board[dest].count === 1) {
          moves.push({from: "bar", to: dest, die, hit: true});
        }
      }
      return moves;
    }

    function makeMove(move) {
      try {
        if (move.from === "bar") {
          bar[currentTurn]--;
        } else {
          if (board[move.from]) {
            board[move.from].count--;
            if (board[move.from].count === 0) board[move.from] = null;
          } else {
            logBug("makeMove", "No checker at source " + move.from);
          }
        }
        if (move.bearOff) {
          borneOff[currentTurn]++;
        } else {
          if (move.hit) {
            if (board[move.to] && board[move.to].owner !== currentTurn && board[move.to].count === 1) {
              bar[ board[move.to].owner ]++;
              board[move.to] = { owner: currentTurn, count: 1 };
            }
          } else {
            if (!board[move.to]) {
              board[move.to] = { owner: currentTurn, count: 1 };
            } else if (board[move.to].owner === currentTurn) {
              board[move.to].count++;
            }
          }
        }
        const index = currentDice.indexOf(move.die);
        if (index !== -1) { currentDice.splice(index, 1); }
        selectedPoint = null;
        legalMoves = [];
      } catch (err) {
        logBug("makeMove", err);
      }
    }

    function checkGameOver() {
      if (borneOff['w'] >= 15) {
        gameState = "game_over";
        gameOverText.textContent = "Game Over: White wins!";
        showGameOver();
        return true;
      } else if (borneOff['b'] >= 15) {
        gameState = "game_over";
        gameOverText.textContent = "Game Over: Black wins!";
        showGameOver();
        return true;
      }
      return false;
    }

    /************ Input Handling for Human Moves ************/
    boardCanvas.addEventListener("mousedown", (e) => {
      if (currentTurn !== playerColor) return;  // Only allow human input on their turn.
      try {
        const rect = boardCanvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        let clickedPoint = getPointFromCoordinates(mx, my);
        // If checkers on bar, force re-entry.
        if (bar[currentTurn] > 0) {
          let reEntryMoves = getLegalMovesFromBar();
          if (reEntryMoves.length === 0) return;
          selectedPoint = "bar";
          legalMoves = reEntryMoves;
          const move = reEntryMoves.find(m => m.to === clickedPoint);
          if (move) {
            redrawGame();
            setTimeout(() => {
              makeMove(move);
              redrawGame();
              if (currentDice.length === 0 && !hasLegalMoves()) endTurn();
            }, humanDelay);
          }
          return;
        }
        if (clickedPoint === null) return;
        if (selectedPoint === null) {
          if (board[clickedPoint] && board[clickedPoint].owner === currentTurn) {
            const moves = getLegalMoves(clickedPoint);
            if (moves.length > 0) {
              selectedPoint = clickedPoint;
              legalMoves = moves;
            }
          }
        } else {
          const move = legalMoves.find(m => m.to === clickedPoint);
          if (move) {
            selectedPoint = move.from;
            legalMoves = [move];
            redrawGame();
            setTimeout(() => {
              makeMove(move);
              redrawGame();
              if (!checkGameOver() && currentDice.length === 0 && !hasLegalMoves()) endTurn();
            }, humanDelay);
          } else {
            selectedPoint = null;
            legalMoves = [];
          }
        }
        redrawGame();
      } catch (err) {
        logBug("boardCanvas mousedown", err);
      }
    });

    function getPointFromCoordinates(x, y) {
      try {
        const boardMargin = 20;
        const boardWidth = WIDTH - 2 * boardMargin;
        const boardTop = 100;
        const boardHeight = 600;
        if (y < boardTop || y > boardTop + boardHeight) return null;
        const pointWidth = boardWidth / 12;
        let isTop = y < boardTop + boardHeight / 2;
        let pointIndex;
        if (isTop) {
          let pos = Math.floor((x - boardMargin) / pointWidth);
          pointIndex = 23 - pos;
        } else {
          let pos = Math.floor((x - boardMargin) / pointWidth);
          pointIndex = pos;
        }
        return pointIndex;
      } catch (err) {
        logBug("getPointFromCoordinates", err);
        return null;
      }
    }

    function endTurn() {
      currentTurn = (currentTurn === 'w') ? 'b' : 'w';
      if (!checkGameOver()) {
        if (currentTurn !== playerColor) {
          aiTurn();
        } else {
          rollDiceBtn.style.display = "block";
        }
      }
    }

    /************ AI Turn (Opponent Moves) ************/
    function aiTurn() {
      if (currentTurn === playerColor) return;
      aiThinking = true;
      let aiDelay = getAIDelay();
      setTimeout(() => {
        currentDice = rollDice();
        drawDiceOnCanvas();
        function aiMakeMove() {
          let possibleMoves = [];
          if (bar[currentTurn] > 0) {
            possibleMoves = getLegalMovesFromBar();
          } else {
            for (let i = 0; i < 24; i++) {
              if (board[i] && board[i].owner === currentTurn) {
                let moves = getLegalMoves(i);
                if (moves.length > 0) {
                  possibleMoves = possibleMoves.concat(moves);
                }
              }
            }
          }
          if (possibleMoves.length > 0) {
            let move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
            selectedPoint = move.from;
            legalMoves = [move];
            redrawGame();
            setTimeout(() => {
              makeMove(move);
              redrawGame();
              if (currentDice.length > 0) {
                setTimeout(aiMakeMove, aiDelay);
              } else {
                aiThinking = false;
                currentTurn = (currentTurn === 'w') ? 'b' : 'w';
                if (currentTurn === playerColor) {
                  rollDiceBtn.style.display = "block";
                } else {
                  setTimeout(aiTurn, aiDelay);
                }
              }
            }, aiDelay);
          } else {
            aiThinking = false;
            currentTurn = (currentTurn === 'w') ? 'b' : 'w';
            if (currentTurn === playerColor) {
              rollDiceBtn.style.display = "block";
            } else {
              setTimeout(aiTurn, aiDelay);
            }
          }
        }
        aiMakeMove();
      }, aiDelay);
    }

    /************ Overlay & Menu Management ************/
    function hideAllScreens() {
      menuScreen.style.display = "none";
      instructionsScreen.style.display = "none";
      colorScreen.style.display = "none";
      difficultyScreen.style.display = "none";
      gameOverScreen.style.display = "none";
    }
    function showMenu() {
      hideAllScreens();
      gameState = "menu";
      menuScreen.style.display = "flex";
    }
    function showInstructions() {
      hideAllScreens();
      gameState = "instructions";
      instructionsScreen.style.display = "flex";
    }
    function showColorChoice() {
      hideAllScreens();
      gameState = "color_choice";
      colorScreen.style.display = "flex";
    }
    function showDifficultyChoice() {
      hideAllScreens();
      gameState = "difficulty_choice";
      difficultyScreen.style.display = "flex";
    }
    function startGame() {
      hideAllScreens();
      gameState = "playing";
      initBoard();
      redrawGame();
      if (currentTurn === playerColor) {
        rollDiceBtn.style.display = "block";
      } else {
        rollDiceBtn.style.display = "none";
        aiTurn();
      }
    }
    function showGameOver() {
      hideAllScreens();
      gameState = "game_over";
      gameOverScreen.style.display = "flex";
    }

    document.getElementById("newGameBtn").onclick = function() { showColorChoice(); };
    document.getElementById("instructionsBtn").onclick = function() { showInstructions(); };
    document.getElementById("whiteSideBtn").onclick = function() { playerColor = "w"; showDifficultyChoice(); };
    document.getElementById("blackSideBtn").onclick = function() { playerColor = "b"; showDifficultyChoice(); };
    document.getElementById("easyBtn").onclick = function() { difficulty = "easy"; startGame(); };
    document.getElementById("mediumBtn").onclick = function() { difficulty = "medium"; startGame(); };
    document.getElementById("hardBtn").onclick = function() { difficulty = "hard"; startGame(); };
    document.getElementById("gameOverNewGameBtn").onclick = function() { showColorChoice(); };
    document.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      if (gameState === "color_choice") {
        if (key === "w") document.getElementById("whiteSideBtn").click();
        if (key === "b") document.getElementById("blackSideBtn").click();
      } else if (gameState === "difficulty_choice") {
        if (key === "e") document.getElementById("easyBtn").click();
        if (key === "m") document.getElementById("mediumBtn").click();
        if (key === "h") document.getElementById("hardBtn").click();
      } else if (["playing", "instructions", "game_over"].includes(gameState)) {
        if (key === "m") showMenu();
      }
    });

    /************ Main Loop ************/
    function mainLoop() {
      if (gameState === "playing") { redrawGame(); }
      requestAnimationFrame(mainLoop);
    }
    window.addEventListener("load", () => {
      showMenu();
      mainLoop();
    });
  </script>
</body>
</html>
