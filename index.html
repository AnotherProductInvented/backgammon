<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Backgammon – Revised</title>
  <style>
    body { margin:0; padding:0; background:#fff; font-family:sans-serif; display:flex; flex-direction:column; align-items:center; }
    h1 { margin:1rem 0 0.5rem; text-align:center; }
    .overlayScreen {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      display: none; background: rgba(255,255,255,0.95);
      align-items: center; justify-content: center; flex-direction: column; text-align: center;
      z-index: 5;
    }
    button { font-size:18px; margin:10px; padding:10px 20px; cursor:pointer; }
    #mainContainer { display: flex; flex-direction: row; align-items: flex-start; margin-top: 60px; }
    #barContainer { width: 150px; text-align: center; }
    #boardContainer { position: relative; width:720px; height:800px; background:#f5f5f5; margin:0 20px; }
    #diceContainer { width:150px; text-align:center; }
    canvas { background:#fff; border:2px solid #000; display:block; margin:10px auto; }
    #logo { position: fixed; bottom:10px; right:10px; max-width:100px; z-index:2000; }
  </style>
</head>
<body>
  <!-- Overlays -->
  <div id="menuScreen" class="overlayScreen" style="display:flex;">
    <h1>Backgammon</h1>
    <button id="newGameBtn">New Game</button>
    <button id="instructionsBtn">Instructions</button>
  </div>
  <div id="colorScreen" class="overlayScreen">
    <p>Choose Your Color:</p>
    <button id="whiteSideBtn">White [W]</button>
    <button id="blackSideBtn">Black [B]</button>
    <p>You can also press W or B.</p>
  </div>
  <div id="difficultyScreen" class="overlayScreen">
    <p>Select Difficulty:</p>
    <button id="easyBtn">Easy [E]</button>
    <button id="mediumBtn">Medium [M]</button>
    <button id="hardBtn">Hard [H]</button>
    <p>You can also press E, M, or H.</p>
  </div>
  <div id="instructionsScreen" class="overlayScreen">
    <h2>How to Play</h2>
    <p>
      Black moves from point 1 up to 24 (by adding die) and bears off only when all checkers are in points 19–24.<br>
      White moves from point 24 down to 1 (by subtracting die) and bears off only when all checkers are in points 1–6.<br>
      A hit checker goes to the bar and must re‑enter into the opponent’s home board.
    </p>
    <p>Press [M] to return.</p>
  </div>
  <div id="gameOverScreen" class="overlayScreen">
    <h2 id="gameOverText"></h2>
    <button id="gameOverNewGameBtn">New Game</button>
    <p>Press [M] to return.</p>
  </div>

  <!-- Main Container -->
  <div id="mainContainer">
    <div id="barContainer">
      <h3>Bar</h3>
      <canvas id="barCanvas" width="150" height="200"></canvas>
    </div>
    <div id="boardContainer">
      <canvas id="boardCanvas" width="720" height="800"></canvas>
    </div>
    <div id="diceContainer">
      <button id="rollDiceBtn" style="display:none;">Roll Dice</button>
      <canvas id="diceCanvas" width="150" height="70"></canvas>
    </div>
  </div>
  <img id="logo" src="logo.png" alt="Logo">

  <script>
    /********** Bug Logging **********/
    let bugLogs = [];
    function logBug(loc, details) {
      const entry = { time: new Date().toISOString(), loc, details };
      bugLogs.push(entry);
      console.error("Bug:", entry);
    }
    window.onerror = (msg, src, line, col, err) => logBug("Global", {msg, src, line, col, err});

    /********** Globals & Constants **********/
    const boardCanvas = document.getElementById("boardCanvas"),
          ctx = boardCanvas.getContext("2d"),
          diceCanvas = document.getElementById("diceCanvas"),
          diceCtx = diceCanvas.getContext("2d"),
          barCanvas = document.getElementById("barCanvas"),
          barCtx = barCanvas.getContext("2d");

    const menuScreen = document.getElementById("menuScreen"),
          instructionsScreen = document.getElementById("instructionsScreen"),
          colorScreen = document.getElementById("colorScreen"),
          difficultyScreen = document.getElementById("difficultyScreen"),
          gameOverScreen = document.getElementById("gameOverScreen"),
          gameOverText = document.getElementById("gameOverText"),
          rollDiceBtn = document.getElementById("rollDiceBtn");

    const WIDTH = 720, HEIGHT = 800,
          boardMargin = 20, boardTop = 100, boardHeight = 600,
          boardWidth = WIDTH - 2*boardMargin, pointWidth = boardWidth/12;

    let gameState = "menu", playerColor = null, difficulty = null,
        currentTurn = "w", selectedPoint = null, legalMoves = [],
        currentDice = [], aiThinking = false,
        borneOff = { w:0, b:0 },
        board = new Array(24).fill(null),
        bar = { w:0, b:0 };

    const humanDelay = 300;
    function getAIDelay() {
      return difficulty==="hard" ? 1800 : difficulty==="medium" ? 1500 : 1200;
    }

    /********** Game Initialization **********/
    function initBoard() {
      try {
        board.fill(null);
        borneOff = { w:0, b:0 };
        bar = { w:0, b:0 };
        // Standard positions (using our numbering):
        // White (moves from 24 down to 1):
        board[23] = { owner: 'w', count: 2 };  // point 24
        board[12] = { owner: 'w', count: 5 };  // point 13
        board[7]  = { owner: 'w', count: 3 };  // point 8
        board[5]  = { owner: 'w', count: 5 };  // point 6
        // Black (moves from 1 up to 24):
        board[0]  = { owner: 'b', count: 2 };  // point 1
        board[11] = { owner: 'b', count: 5 };  // point 12
        board[16] = { owner: 'b', count: 3 };  // point 17
        board[18] = { owner: 'b', count: 5 };  // point 19
        currentTurn = "w"; currentDice = [];
        selectedPoint = null; legalMoves = [];
      } catch(err) { logBug("initBoard",err); }
    }

    /********** Dice Functions **********/
    function rollDice() {
      try {
        const d1 = Math.floor(Math.random()*6)+1,
              d2 = Math.floor(Math.random()*6)+1;
        return d1===d2 ? [d1,d1,d1,d1] : [d1,d2];
      } catch(err) { logBug("rollDice",err); return []; }
    }
    function drawDiceOnCanvas() {
      diceCtx.clearRect(0,0,diceCanvas.width,diceCanvas.height);
      if (!currentDice.length) return;
      const diceToShow = currentDice.slice(0,2),
            diceSize = 60, spacing = 10;
      diceToShow.forEach((d,i) => drawDieOnCanvas(diceCtx, i*(diceSize+spacing),0,diceSize,d));
    }
    function drawDieOnCanvas(ctx,x,y,size,value) {
      ctx.fillStyle="#fff"; ctx.fillRect(x,y,size,size);
      ctx.strokeStyle="#000"; ctx.strokeRect(x,y,size,size);
      ctx.fillStyle="#000";
      const dotRadius = size/10, cx=x+size/2, cy=y+size/2;
      const positions = {
        tl: { x: x+size*0.25, y: y+size*0.25 },
        tr: { x: x+size*0.75, y: y+size*0.25 },
        mid: { x: cx, y: cy },
        bl: { x: x+size*0.25, y: y+size*0.75 },
        br: { x: x+size*0.75, y: y+size*0.75 },
        ml: { x: x+size*0.25, y: cy },
        mr: { x: x+size*0.75, y: cy }
      };
      function drawDot(pos) { ctx.beginPath(); ctx.arc(pos.x,pos.y,dotRadius,0,2*Math.PI); ctx.fill(); }
      switch(value){
        case 1: drawDot(positions.mid); break;
        case 2: drawDot(positions.tl); drawDot(positions.br); break;
        case 3: drawDot(positions.tl); drawDot(positions.mid); drawDot(positions.br); break;
        case 4: drawDot(positions.tl); drawDot(positions.tr); drawDot(positions.bl); drawDot(positions.br); break;
        case 5: drawDot(positions.tl); drawDot(positions.tr); drawDot(positions.mid); drawDot(positions.bl); drawDot(positions.br); break;
        case 6: drawDot(positions.tl); drawDot(positions.tr); drawDot(positions.ml); drawDot(positions.mr); drawDot(positions.bl); drawDot(positions.br); break;
      }
    }

    rollDiceBtn.onclick = function(){
      if(!currentDice.length && currentTurn===playerColor){
        currentDice = rollDice();
        drawDiceOnCanvas();
        rollDiceBtn.style.display = "none";
        redrawGame();
      }
    };

    /********** Drawing the Board **********/
    function drawBoard(){
      try {
        ctx.clearRect(0,0,WIDTH,HEIGHT);
        ctx.fillStyle="#f5f5f5"; ctx.fillRect(0,0,WIDTH,HEIGHT);
        ctx.fillStyle="#006400"; ctx.fillRect(boardMargin, boardTop, boardWidth, boardHeight);
        // Top row: points 13–24 (drawn left-to-right)
        for(let p=13; p<=24; p++){
          let idx = p-1;
          let x = boardMargin + (p-13)*pointWidth;
          let y = boardTop;
          let tri = { x, y, width: pointWidth, height: boardHeight/2, direction:"down" };
          let color = (p%2===0) ? "#deb887" : "#d2b48c";
          drawTriangle(tri.x,tri.y,tri.width,tri.height,tri.direction,color);
        }
        // Bottom row: points 1–12 but drawn right-to-left.
        for(let p=1; p<=12; p++){
          // Let pos = 12 - p so that point 1 (p=1) appears at rightmost.
          let pos = 12 - p;
          let idx = p-1;
          let x = boardMargin + pos*pointWidth;
          let y = boardTop + boardHeight/2;
          let tri = { x, y, width: pointWidth, height: boardHeight/2, direction:"up" };
          let color = (p%2===0) ? "#deb887" : "#d2b48c";
          drawTriangle(tri.x,tri.y,tri.width,tri.height,tri.direction,color);
        }
        drawBorneOff();
      } catch(err){ logBug("drawBoard",err); }
    }
    function drawTriangle(x,y,width,height,direction,color){
      try{
        ctx.fillStyle = color;
        ctx.beginPath();
        if(direction==="up"){
          ctx.moveTo(x,y+height);
          ctx.lineTo(x+width/2,y);
          ctx.lineTo(x+width,y+height);
        } else { // "down"
          ctx.moveTo(x,y);
          ctx.lineTo(x+width/2,y+height);
          ctx.lineTo(x+width,y);
        }
        ctx.closePath(); ctx.fill(); ctx.strokeStyle="#000"; ctx.stroke();
      } catch(err){ logBug("drawTriangle",err); }
    }
    // Map board index to triangle coordinates.
    function getTriangleCoordinates(idx){
      let x,y,width=pointWidth,height;
      if(idx>=12 && idx<=23){
        // Top row: points 13–24 drawn left-to-right.
        let p = idx+1; // p: 13-24.
        x = boardMargin + (p-13)*pointWidth;
        y = boardTop; height = boardHeight/2;
        return { x,y,width,height, direction:"down" };
      } else if(idx>=0 && idx<=11){
        // Bottom row: points 1–12 drawn in reverse (right-to-left).
        let p = idx+1;
        let pos = 12 - p; // so p=1 => pos=11, p=12 => pos=0.
        x = boardMargin + pos*pointWidth;
        y = boardTop + boardHeight/2; height = boardHeight/2;
        return { x,y,width,height, direction:"up" };
      } else return null;
    }

    /********** Borne-off Drawing **********/
    function drawBorneOff(){
      const pieceRadius = 20;
      // White borne-off: drawn in top right.
      for(let i=0; i<borneOff.w; i++){
        let x = WIDTH - 50, y = boardTop + 20 + i*(pieceRadius*2.2);
        ctx.beginPath(); ctx.arc(x,y,pieceRadius,0,2*Math.PI);
        ctx.fillStyle="#fff"; ctx.fill(); ctx.strokeStyle="#000"; ctx.stroke();
      }
      // Black borne-off: drawn in bottom left.
      for(let i=0; i<borneOff.b; i++){
        let x = boardMargin + 50, y = boardTop + boardHeight - 50 - i*(pieceRadius*2.2);
        ctx.beginPath(); ctx.arc(x,y,pieceRadius,0,2*Math.PI);
        ctx.fillStyle="#000"; ctx.fill(); ctx.strokeStyle="#000"; ctx.stroke();
      }
    }

    /********** Pieces Drawing **********/
    function drawPieces(){
      try {
        ctx.font="20px sans-serif"; ctx.textAlign="center"; ctx.textBaseline="middle";
        for(let i=0; i<24; i++){
          if(!board[i]) continue;
          let tri = getTriangleCoordinates(i);
          let centerX = tri.x + tri.width/2;
          let spacing = Math.min(tri.width,tri.height)/2.2;
          for(let j=0; j<board[i].count; j++){
            let centerY;
            if(i>=12) { // top row: stack from top
              centerY = tri.y + (j+0.5)*spacing;
            } else { // bottom row: stack from bottom
              centerY = tri.y + tri.height - (j+0.5)*spacing;
            }
            ctx.beginPath();
            ctx.arc(centerX, centerY, spacing*0.8, 0, 2*Math.PI);
            ctx.fillStyle = (board[i].owner==='w') ? "#fff" : "#000";
            ctx.fill(); ctx.strokeStyle="#000"; ctx.stroke();
          }
          if(board[i].count > 5){
            ctx.fillStyle="red";
            ctx.fillText(board[i].count, centerX, (i>=12) ? tri.y+3*spacing : tri.y+tri.height-3*spacing);
          }
        }
      } catch(err){ logBug("drawPieces",err); }
    }

    /********** Highlighting Legal Moves **********/
    function highlightLegalOptions(){
      if(selectedPoint!==null){
        let selCoords = getTriangleCoordinates(selectedPoint);
        if(selCoords){
          ctx.fillStyle = "rgba(0,255,255,0.5)";
          ctx.fillRect(selCoords.x, selCoords.y, selCoords.width, selCoords.height);
        }
        legalMoves.forEach(move => {
          if(move.bearOff){
            // For white: highlight borne-off area in top right; for black: bottom left.
            let x,y, rectW=60, rectH=60;
            if(currentTurn==='w'){
              x = WIDTH - rectW - 20; y = boardTop + 20;
            } else {
              x = boardMargin + 20; y = boardTop + boardHeight - rectH - 20;
            }
            ctx.fillStyle = "rgba(255,255,0,0.5)";
            ctx.fillRect(x,y,rectW,rectH);
          } else {
            let destCoords = getTriangleCoordinates(move.to);
            if(destCoords){
              ctx.fillStyle = "rgba(255,255,0,0.5)";
              ctx.fillRect(destCoords.x, destCoords.y, destCoords.width, destCoords.height);
            }
          }
        });
      }
    }

    /********** Move Logic **********/
    // Black moves by adding die; white subtracts.
    function canBearOff(color){
      let inHome = true;
      for(let i=0;i<24;i++){
        if(board[i] && board[i].owner===color){
          if(color==='w' && i > 5) inHome = false;  // white's home: points 1-6 (indices 0-5)
          if(color==='b' && i < 18) inHome = false; // black's home: points 19-24 (indices 18-23)
        }
      }
      if(bar[color] > 0) inHome = false;
      return inHome;
    }
    function getLegalMoves(pointIndex){
      let moves = [];
      if(!board[pointIndex] || board[pointIndex].owner!==currentTurn) return moves;
      for(let die of currentDice){
        let dest;
        if(currentTurn==='w'){
          dest = pointIndex - die;
          if(dest < 0 && canBearOff('w')){
            moves.push({from: pointIndex, to: -1, die, bearOff:true});
            continue;
          }
        } else {
          dest = pointIndex + die;
          if(dest > 23 && canBearOff('b')){
            moves.push({from: pointIndex, to: 24, die, bearOff:true});
            continue;
          }
        }
        if(dest < 0 || dest > 23) continue;
        if(!board[dest]){
          moves.push({from: pointIndex, to: dest, die});
        } else if(board[dest].owner===currentTurn){
          moves.push({from: pointIndex, to: dest, die});
        } else if(board[dest].count===1){
          moves.push({from: pointIndex, to: dest, die, hit:true});
        }
      }
      return moves;
    }
    function getLegalMovesFromBar(){
      let moves = [];
      if(bar[currentTurn] <= 0) return moves;
      for(let die of currentDice){
        let dest;
        if(currentTurn==='w'){
          // White re-enters into opponent’s home (points 19-24)
          dest = 24 - die; // die=1 => index 23; die=6 => index 18.
        } else {
          // Black re-enters into opponent’s home (points 1-6)
          dest = die - 1;  // die=1 => index 0; die=6 => index 5.
        }
        if(dest < 0 || dest > 23) continue;
        if(!board[dest]){
          moves.push({from:"bar", to:dest, die});
        } else if(board[dest].owner===currentTurn){
          moves.push({from:"bar", to:dest, die});
        } else if(board[dest].count===1){
          moves.push({from:"bar", to:dest, die, hit:true});
        }
      }
      return moves;
    }
    function makeMove(move){
      try {
        if(move.from==="bar"){
          bar[currentTurn]--;
        } else {
          if(board[move.from]){
            board[move.from].count--;
            if(board[move.from].count===0) board[move.from]=null;
          } else { logBug("makeMove","No checker at "+move.from); }
        }
        if(move.bearOff){
          borneOff[currentTurn]++;
        } else {
          if(move.hit){
            if(board[move.to] && board[move.to].owner!==currentTurn && board[move.to].count===1){
              bar[board[move.to].owner]++;
              board[move.to] = { owner: currentTurn, count:1 };
            }
          } else {
            if(!board[move.to]){
              board[move.to] = { owner: currentTurn, count:1 };
            } else if(board[move.to].owner===currentTurn){
              board[move.to].count++;
            }
          }
        }
        const idx = currentDice.indexOf(move.die);
        if(idx!==-1) currentDice.splice(idx,1);
        selectedPoint = null; legalMoves = [];
      } catch(err){ logBug("makeMove",err); }
    }
    function checkGameOver(){
      if(borneOff['w']>=15){
        gameState="game_over";
        gameOverText.textContent="Game Over: White wins!";
        showGameOver();
        return true;
      } else if(borneOff['b']>=15){
        gameState="game_over";
        gameOverText.textContent="Game Over: Black wins!";
        showGameOver();
        return true;
      }
      return false;
    }

    /********** Input Handling **********/
    boardCanvas.addEventListener("mousedown", (e)=>{
      if(currentTurn!==playerColor) return;
      try {
        const rect = boardCanvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        let clicked = getPointFromCoordinates(mx,my);
        if(bar[currentTurn] > 0){
          let reEntry = getLegalMovesFromBar();
          if(!reEntry.length) return;
          selectedPoint = "bar"; legalMoves = reEntry;
          let move = reEntry.find(m=> m.to===clicked);
          if(move){
            redrawGame();
            setTimeout(()=>{
              makeMove(move);
              redrawGame();
              if(!currentDice.length && !hasLegalMoves()) endTurn();
            }, humanDelay);
          }
          return;
        }
        if(clicked===null) return;
        if(selectedPoint===null){
          if(board[clicked] && board[clicked].owner===currentTurn){
            const moves = getLegalMoves(clicked);
            if(moves.length){
              selectedPoint = clicked; legalMoves = moves;
            }
          }
        } else {
          let move = legalMoves.find(m=> m.to===clicked);
          if(move){
            selectedPoint = move.from; legalMoves = [move];
            redrawGame();
            setTimeout(()=>{
              makeMove(move);
              redrawGame();
              if(!checkGameOver() && !currentDice.length && !hasLegalMoves()) endTurn();
            }, humanDelay);
          } else { selectedPoint = null; legalMoves = []; }
        }
        redrawGame();
      } catch(err){ logBug("boardCanvas mousedown",err); }
    });
    function getPointFromCoordinates(x,y){
      try{
        if(y<boardTop || y>boardTop+boardHeight) return null;
        let pt;
        if(y < boardTop+boardHeight/2){
          // Top half: points 13-24.
          let pos = Math.floor((x-boardMargin)/pointWidth);
          pt = pos + 13;
        } else {
          // Bottom half: points 1-12 (but note: drawn reversed).
          let pos = Math.floor((x-boardMargin)/pointWidth);
          // Reverse the order: pos 0 corresponds to point 12, pos 11 to point 1.
          pt = 12 - pos;
        }
        return pt-1; // convert to 0-index.
      } catch(err){ logBug("getPointFromCoordinates",err); return null; }
    }
    function hasLegalMoves(){
      let moves = [];
      if(bar[currentTurn] > 0) moves = getLegalMovesFromBar();
      else {
        for(let i=0;i<24;i++){
          if(board[i] && board[i].owner===currentTurn){
            let m = getLegalMoves(i);
            if(m.length) moves = moves.concat(m);
          }
        }
      }
      return moves.length>0;
    }
    function endTurn(){
      currentTurn = (currentTurn==='w') ? 'b' : 'w';
      if(!checkGameOver()){
        if(currentTurn!==playerColor) aiTurn();
        else rollDiceBtn.style.display="block";
      }
    }

    /********** AI Turn **********/
    function aiTurn(){
      if(currentTurn===playerColor) return;
      aiThinking = true;
      let delay = getAIDelay();
      setTimeout(()=>{
        currentDice = rollDice(); drawDiceOnCanvas();
        function aiMakeMove(){
          let poss = [];
          if(bar[currentTurn] > 0) poss = getLegalMovesFromBar();
          else {
            for(let i=0;i<24;i++){
              if(board[i] && board[i].owner===currentTurn){
                let m = getLegalMoves(i);
                if(m.length) poss = poss.concat(m);
              }
            }
          }
          if(poss.length){
            let move = poss[Math.floor(Math.random()*poss.length)];
            selectedPoint = move.from; legalMoves = [move];
            redrawGame();
            setTimeout(()=>{
              makeMove(move);
              redrawGame();
              if(currentDice.length) setTimeout(aiMakeMove,delay);
              else { aiThinking=false; currentTurn = (currentTurn==='w')?'b':'w';
                if(currentTurn===playerColor) rollDiceBtn.style.display="block";
                else setTimeout(aiTurn,delay);
              }
            },delay);
          } else {
            aiThinking=false; currentTurn = (currentTurn==='w')?'b':'w';
            if(currentTurn===playerColor) rollDiceBtn.style.display="block";
            else setTimeout(aiTurn,delay);
          }
        }
        aiMakeMove();
      }, delay);
    }

    /********** Overlays & Menus **********/
    function hideAllScreens(){
      menuScreen.style.display = "none";
      instructionsScreen.style.display = "none";
      colorScreen.style.display = "none";
      difficultyScreen.style.display = "none";
      gameOverScreen.style.display = "none";
    }
    function showMenu(){ hideAllScreens(); gameState="menu"; menuScreen.style.display="flex"; }
    function showInstructions(){ hideAllScreens(); gameState="instructions"; instructionsScreen.style.display="flex"; }
    function showColorChoice(){ hideAllScreens(); gameState="color_choice"; colorScreen.style.display="flex"; }
    function showDifficultyChoice(){ hideAllScreens(); gameState="difficulty_choice"; difficultyScreen.style.display="flex"; }
    function startGame(){
      hideAllScreens(); gameState="playing"; initBoard(); redrawGame();
      if(currentTurn===playerColor) rollDiceBtn.style.display="block"; else { rollDiceBtn.style.display="none"; aiTurn(); }
    }
    function showGameOver(){ hideAllScreens(); gameState="game_over"; gameOverScreen.style.display="flex"; }

    document.getElementById("newGameBtn").onclick = ()=> { showColorChoice(); };
    document.getElementById("instructionsBtn").onclick = ()=> { showInstructions(); };
    document.getElementById("whiteSideBtn").onclick = ()=> { playerColor="w"; showDifficultyChoice(); };
    document.getElementById("blackSideBtn").onclick = ()=> { playerColor="b"; showDifficultyChoice(); };
    document.getElementById("easyBtn").onclick = ()=> { difficulty="easy"; startGame(); };
    document.getElementById("mediumBtn").onclick = ()=> { difficulty="medium"; startGame(); };
    document.getElementById("hardBtn").onclick = ()=> { difficulty="hard"; startGame(); };
    document.getElementById("gameOverNewGameBtn").onclick = ()=> { showColorChoice(); };
    document.addEventListener("keydown",(e)=>{
      const key = e.key.toLowerCase();
      if(gameState==="color_choice"){
        if(key==="w") document.getElementById("whiteSideBtn").click();
        if(key==="b") document.getElementById("blackSideBtn").click();
      } else if(gameState==="difficulty_choice"){
        if(key==="e") document.getElementById("easyBtn").click();
        if(key==="m") document.getElementById("mediumBtn").click();
        if(key==="h") document.getElementById("hardBtn").click();
      } else if(["playing","instructions","game_over"].includes(gameState)){
        if(key==="m") showMenu();
      }
    });

    /********** Redraw & Main Loop **********/
    function redrawGame(){
      try { drawBoard(); highlightLegalOptions(); drawPieces(); drawDiceOnCanvas(); drawBarPieces(); }
      catch(err){ logBug("redrawGame",err); }
    }
    function mainLoop(){ if(gameState==="playing") redrawGame(); requestAnimationFrame(mainLoop); }
    window.addEventListener("load", ()=> { showMenu(); mainLoop(); });

    /********** Bar Drawing **********/
    function drawBarPieces(){
      try {
        barCtx.clearRect(0,0,barCanvas.width,barCanvas.height);
        barCtx.font="16px sans-serif"; barCtx.fillStyle="#000";
        barCtx.fillText("Bar", barCanvas.width/2,20);
        const pieceRadius = 15, spacing = pieceRadius*2.2;
        // White pieces on top of bar.
        for(let j=0;j<bar.w;j++){
          let cx = barCanvas.width/2, cy = 40 + j*spacing;
          barCtx.beginPath(); barCtx.arc(cx,cy,pieceRadius,0,2*Math.PI);
          barCtx.fillStyle="#fff"; barCtx.fill(); barCtx.strokeStyle="#000"; barCtx.stroke();
        }
        // Black pieces on bottom of bar.
        for(let j=0;j<bar.b;j++){
          let cx = barCanvas.width/2, cy = barCanvas.height-40 - j*spacing;
          barCtx.beginPath(); barCtx.arc(cx,cy,pieceRadius,0,2*Math.PI);
          barCtx.fillStyle="#000"; barCtx.fill(); barCtx.strokeStyle="#000"; barCtx.stroke();
        }
      } catch(err){ logBug("drawBarPieces",err); }
    }
  </script>
</body>
</html>
