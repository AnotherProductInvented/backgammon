<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Backgammon – Integrated Bear-Off Zones</title>
  <style>
    body {
      margin: 0; padding: 0;
      background: #fff;
      font-family: sans-serif;
      display: flex; flex-direction: column; align-items: center;
    }
    h1 { margin: 1rem 0 0.5rem; text-align: center; }
    .overlayScreen {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      background: rgba(255,255,255,0.95);
      align-items: center; justify-content: center;
      flex-direction: column; text-align: center;
      z-index: 5;
    }
    #noLegalMoveOverlay { font-size: 48px; color: red; }
    #customRollOverlay { font-size: 20px; }
    button { font-size: 18px; margin: 10px; padding: 10px 20px; cursor: pointer; }
    input { font-size: 18px; margin: 5px; padding: 5px; width: 50px; text-align: center; }
    /* Main container now has 3 columns: Bar, Board, Dice */
    #mainContainer {
      display: flex; flex-direction: row; align-items: flex-start; margin-top: 20px;
    }
    #barContainer { width: 150px; text-align: center; }
    #boardContainer { position: relative; width: 720px; height: 800px; background: #f5f5f5; margin: 0 20px; }
    #diceContainer { width: 150px; text-align: center; }
    canvas {
      background: #fff; border: 2px solid #000;
      display: block; margin: 10px auto;
    }
    #logo { position: fixed; bottom: 10px; right: 10px; max-width: 100px; z-index: 2000; }
  </style>
</head>
<body>
  <!-- Menus & Overlays -->
  <div id="menuScreen" class="overlayScreen" style="display: flex;">
    <h1>Backgammon</h1>
    <button id="newGameBtn">New Game</button>
    <button id="instructionsBtn">Instructions</button>
  </div>
  <div id="colorScreen" class="overlayScreen">
    <p>Choose Your Color:</p>
    <button id="whiteSideBtn">White [W]</button>
    <button id="blackSideBtn">Black [B]</button>
    <p>You can also press W or B.</p>
  </div>
  <div id="difficultyScreen" class="overlayScreen">
    <p>Select Difficulty:</p>
    <button id="easyBtn">Easy [E]</button>
    <button id="mediumBtn">Medium [M]</button>
    <button id="hardBtn">Hard [H]</button>
    <p>You can also press E, M, or H.</p>
  </div>
  <div id="instructionsScreen" class="overlayScreen">
    <h2>How to Play</h2>
    <p>
      Rolling the Dice – Each player rolls two dice and moves their checkers based on the numbers rolled.<br>
      Moving Checkers – Checkers move toward your home board. You can split or combine dice values for movement.<br>
      Landing on a Point – You can land on an open point or one occupied by your checkers. Landing on a single opponent checker (a blot) sends it to the bar.<br>
      Re-entering from the Bar – If you have a checker on the bar, you must enter it before making other moves.<br>
      Bearing Off – Once all your checkers are in your home board, you can start bearing them off by rolling dice matching occupied points.<br>
      (White can bear off only if all white checkers are in points 19–24; Black only if all black checkers are in points 1–6.)<br>
      Winning – The first player to bear off all their checkers wins.<br>
      Press [M] to return to the main menu.
    </p>
  </div>
  <div id="gameOverScreen" class="overlayScreen">
    <h2 id="gameOverText"></h2>
    <button id="gameOverNewGameBtn">New Game</button>
    <p>Press [M] to return.</p>
  </div>
  <!-- "No Legal Move" Overlay -->
  <div id="noLegalMoveOverlay" class="overlayScreen">
    <h2>No Legal Move</h2>
  </div>
  <!-- Custom Roll Overlay (Testing Only) -->
  <div id="customRollOverlay" class="overlayScreen">
    <p>Enter Custom Dice Roll:</p>
    <input type="number" id="customDie1" min="1" max="6" value="1">
    <input type="number" id="customDie2" min="1" max="6" value="1">
    <button id="customRollBtn">Roll Custom</button>
  </div>

  <!-- Main Game Container: Three Columns -->
  <div id="mainContainer">
    <!-- Bar Column -->
    <div id="barContainer">
      <h3>Bar</h3>
      <canvas id="barCanvas" width="150" height="200"></canvas>
    </div>
    <!-- Board Column (integrated bear-off zones) -->
    <div id="boardContainer">
      <canvas id="boardCanvas" width="720" height="800"></canvas>
    </div>
    <!-- Dice Column -->
    <div id="diceContainer">
      <button id="rollDiceBtn" style="display: none;">Roll Dice</button>
      <button id="customRollToggleBtn" style="display: none;">Custom Roll</button>
      <canvas id="diceCanvas" width="150" height="70"></canvas>
    </div>
  </div>
  <img id="logo" src="logo.png" alt="Logo">

  <script>
    // Set testingMode true to enable custom roll controls (set to false for production)
    const testingMode = true;

    /* --- Bug Logging --- */
    let bugLogs = [];
    function logBug(loc, details) {
      const entry = { time: new Date().toISOString(), loc, details };
      bugLogs.push(entry);
      console.error("Bug:", entry);
    }
    window.onerror = (msg, src, line, col, err) => logBug("Global", { msg, src, line, col, err });

    /* --- Globals & Constants --- */
    const boardCanvas = document.getElementById("boardCanvas"),
          ctx = boardCanvas.getContext("2d"),
          diceCanvas = document.getElementById("diceCanvas"),
          diceCtx = diceCanvas.getContext("2d"),
          barCanvas = document.getElementById("barCanvas"),
          barCtx = barCanvas.getContext("2d");

    const menuScreen = document.getElementById("menuScreen"),
          instructionsScreen = document.getElementById("instructionsScreen"),
          colorScreen = document.getElementById("colorScreen"),
          difficultyScreen = document.getElementById("difficultyScreen"),
          gameOverScreen = document.getElementById("gameOverScreen"),
          gameOverText = document.getElementById("gameOverText"),
          rollDiceBtn = document.getElementById("rollDiceBtn"),
          noLegalMoveOverlay = document.getElementById("noLegalMoveOverlay"),
          customRollOverlay = document.getElementById("customRollOverlay"),
          customRollBtn = document.getElementById("customRollBtn"),
          customRollToggleBtn = document.getElementById("customRollToggleBtn");

    // Board dimensions & margins
    const WIDTH = 720, HEIGHT = 800,
          boardMargin = 20, boardTop = 150, boardHeight = 500,
          boardWidth = WIDTH - 2*boardMargin, pointWidth = boardWidth / 12;
    // Note: We increased the top margin to 150 and reduced boardHeight so that we have room
    // at the top (for White's bear-off zone) and bottom (for Black's bear-off zone).

    /* Invisible numbering:
         - Bottom row (right-to‑left): points 1–12 (indices 0–11)
         - Top row (left-to‑right): points 13–24 (indices 12–23)
       Movement:
         • White moves from point 1 → 24 (by adding the die)
         • Black moves from point 24 → 1 (by subtracting the die)
       Home board rules:
         White can bear off only if all white checkers are in points 19–24 (indices 18–23).
         Black can bear off only if all black checkers are in points 1–6 (indices 0–5).
    */
    let gameState = "menu", playerColor = null, difficulty = null,
        currentTurn = "w", selectedPoint = null, legalMoves = [],
        currentDice = [], aiThinking = false,
        borneOff = { w: 0, b: 0 },
        board = new Array(24).fill(null),
        bar = { w: 0, b: 0 };

    const humanDelay = 300;
    function getAIDelay() {
      return difficulty === "hard" ? 1800 : difficulty === "medium" ? 1500 : 1200;
    }

    /* --- Game Initialization --- */
    function initBoard() {
      try {
        board.fill(null);
        borneOff = { w: 0, b: 0 };
        bar = { w: 0, b: 0 };
        // White uses "Black" starting positions (White moves upward from point 1)
        board[0]  = { owner: 'w', count: 2 };      // point 1
        board[11] = { owner: 'w', count: 5 };      // point 12
        board[16] = { owner: 'w', count: 3 };      // point 17
        board[18] = { owner: 'w', count: 5 };      // point 19
        // Black uses "White" starting positions (Black moves downward from point 24)
        board[23] = { owner: 'b', count: 2 };      // point 24
        board[12] = { owner: 'b', count: 5 };      // point 13
        board[7]  = { owner: 'b', count: 3 };      // point 8
        board[5]  = { owner: 'b', count: 5 };      // point 6
        currentTurn = "w";
        currentDice = [];
        selectedPoint = null;
        legalMoves = [];
      } catch (err) { logBug("initBoard", err); }
    }

    /* --- Dice Functions --- */
    function rollDice() {
      try {
        const d1 = Math.floor(Math.random() * 6) + 1,
              d2 = Math.floor(Math.random() * 6) + 1;
        return (d1 === d2) ? [d1, d1, d1, d1] : [d1, d2];
      } catch (err) { logBug("rollDice", err); return []; }
    }
    function drawDiceOnCanvas() {
      diceCtx.clearRect(0, 0, diceCanvas.width, diceCanvas.height);
      if (!currentDice.length) return;
      const diceToShow = currentDice.slice(0, 2),
            diceSize = 60, spacing = 10;
      diceToShow.forEach((d, i) => drawDieOnCanvas(diceCtx, i * (diceSize + spacing), 0, diceSize, d));
    }
    function drawDieOnCanvas(ctx, x, y, size, value) {
      ctx.fillStyle = "#fff";
      ctx.fillRect(x, y, size, size);
      ctx.strokeStyle = "#000";
      ctx.strokeRect(x, y, size, size);
      ctx.fillStyle = "#000";
      const dotRadius = size / 10, cx = x + size / 2, cy = y + size / 2;
      const positions = {
        tl: { x: x + size * 0.25, y: y + size * 0.25 },
        tr: { x: x + size * 0.75, y: y + size * 0.25 },
        mid: { x: cx, y: cy },
        bl: { x: x + size * 0.25, y: y + size * 0.75 },
        br: { x: x + size * 0.75, y: y + size * 0.75 },
        ml: { x: x + size * 0.25, y: cy },
        mr: { x: x + size * 0.75, y: cy }
      };
      function drawDot(pos) { ctx.beginPath(); ctx.arc(pos.x, pos.y, dotRadius, 0, 2 * Math.PI); ctx.fill(); }
      switch (value) {
        case 1: drawDot(positions.mid); break;
        case 2: drawDot(positions.tl); drawDot(positions.br); break;
        case 3: drawDot(positions.tl); drawDot(positions.mid); drawDot(positions.br); break;
        case 4: drawDot(positions.tl); drawDot(positions.tr); drawDot(positions.bl); drawDot(positions.br); break;
        case 5: drawDot(positions.tl); drawDot(positions.tr); drawDot(positions.mid); drawDot(positions.bl); drawDot(positions.br); break;
        case 6: drawDot(positions.tl); drawDot(positions.tr); drawDot(positions.ml); drawDot(positions.mr); drawDot(positions.bl); drawDot(positions.br); break;
      }
    }
    rollDiceBtn.onclick = function () {
      if (!currentDice.length && currentTurn === playerColor) {
        currentDice = rollDice();
        drawDiceOnCanvas();
        if (currentDice.length > 0 && !hasLegalMoves()) {
          currentDice = [];
          showNoLegalMove();
          return;
        }
        rollDiceBtn.style.display = "none";
        redrawGame();
      }
    };

    /* --- Custom Roll (Testing Mode) --- */
    if (testingMode) {
      customRollToggleBtn.style.display = "block";
      customRollToggleBtn.onclick = () => { customRollOverlay.style.display = "flex"; };
      customRollBtn.onclick = () => {
        const die1 = parseInt(document.getElementById("customDie1").value),
              die2 = parseInt(document.getElementById("customDie2").value);
        if (die1 < 1 || die1 > 6 || die2 < 1 || die2 > 6) {
          alert("Enter values 1–6 only.");
          return;
        }
        currentDice = (die1 === die2) ? [die1, die1, die1, die1] : [die1, die2];
        drawDiceOnCanvas();
        customRollOverlay.style.display = "none";
        if (currentDice.length > 0 && !hasLegalMoves()) {
          currentDice = [];
          showNoLegalMove();
          return;
        }
        rollDiceBtn.style.display = "none";
        redrawGame();
      };
    }

    // Update custom roll controls visibility based on whose turn it is.
    function updateCustomRollVisibility() {
      if (testingMode) {
        if (currentTurn === playerColor) {
          customRollToggleBtn.style.display = "block";
        } else {
          customRollToggleBtn.style.display = "none";
        }
      }
    }

    /* --- Board Drawing --- */
    function drawBoard() {
      try {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        // Draw background for bear-off zones (top and bottom)
        // Top 150px reserved for White's bear off.
        ctx.fillStyle = "#e0e0e0";
        ctx.fillRect(0, 0, WIDTH, boardTop);
        // Bottom 100px reserved for Black's bear off.
        ctx.fillStyle = "#e0e0e0";
        ctx.fillRect(0, boardTop + boardHeight, WIDTH, HEIGHT - (boardTop + boardHeight));
        // Draw main board area.
        ctx.fillStyle = "#f5f5f5";
        ctx.fillRect(0, boardTop, WIDTH, boardHeight);
        ctx.fillStyle = "#006400";
        ctx.fillRect(boardMargin, boardTop, boardWidth, boardHeight);
        // Draw triangles for top row (points 13–24)
        for (let p = 13; p <= 24; p++) {
          let idx = p - 1;
          let x = boardMargin + (p - 13) * pointWidth;
          let y = boardTop;
          let tri = { x, y, width: pointWidth, height: boardHeight / 2, direction: "down" };
          let color = (p % 2 === 0) ? "#deb887" : "#d2b48c";
          drawTriangle(tri.x, tri.y, tri.width, tri.height, tri.direction, color);
        }
        // Draw triangles for bottom row (points 1–12)
        for (let p = 1; p <= 12; p++) {
          let pos = 12 - p;
          let x = boardMargin + pos * pointWidth;
          let y = boardTop + boardHeight / 2;
          let tri = { x, y, width: pointWidth, height: boardHeight / 2, direction: "up" };
          let color = (p % 2 === 0) ? "#deb887" : "#d2b48c";
          drawTriangle(tri.x, tri.y, tri.width, tri.height, tri.direction, color);
        }
        // Draw bear-off zones
        drawBearOffZones();
      } catch (err) { logBug("drawBoard", err); }
    }
    function drawTriangle(x, y, width, height, direction, color) {
      try {
        ctx.fillStyle = color;
        ctx.beginPath();
        if (direction === "up") {
          ctx.moveTo(x, y + height);
          ctx.lineTo(x + width / 2, y);
          ctx.lineTo(x + width, y + height);
        } else {
          ctx.moveTo(x, y);
          ctx.lineTo(x + width / 2, y + height);
          ctx.lineTo(x + width, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
      } catch (err) { logBug("drawTriangle", err); }
    }
    function drawBearOffZones() {
      // Draw a blue border for the bear-off zones
      ctx.lineWidth = 3;
      ctx.strokeStyle = "blue";
      ctx.font = "16px sans-serif";
      ctx.fillStyle = "blue";
      // For White (bearing off from the top): zone in the top margin.
      // We'll reserve the top 100px (from y=0 to y=boardTop)
      ctx.strokeRect(boardMargin, 10, boardWidth, boardTop - 20);
      ctx.fillText("White Bear Off", boardMargin + boardWidth / 2, 30);
      // Draw white borne-off pieces in this zone.
      // They will be drawn along the bottom of this zone.
      let pieceRadius = 15, spacing = pieceRadius * 2.2;
      for (let i = 0; i < borneOff.w; i++) {
        let cx = boardMargin + 30 + i * spacing;
        let cy = boardTop - 30;
        ctx.beginPath();
        ctx.arc(cx, cy, pieceRadius, 0, 2 * Math.PI);
        ctx.fillStyle = "#fff";
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
      }
      // For Black (bearing off from the bottom): zone in the bottom margin.
      // Reserve the bottom 100px (from y = boardTop+boardHeight to HEIGHT)
      ctx.strokeRect(boardMargin, boardTop + boardHeight + 10, boardWidth, HEIGHT - (boardTop + boardHeight) - 20);
      ctx.fillText("Black Bear Off", boardMargin + boardWidth / 2, boardTop + boardHeight + 30);
      // Draw black borne-off pieces in this zone.
      for (let i = 0; i < borneOff.b; i++) {
        let cx = boardMargin + 30 + i * spacing;
        let cy = boardTop + boardHeight + 70;
        ctx.beginPath();
        ctx.arc(cx, cy, pieceRadius, 0, 2 * Math.PI);
        ctx.fillStyle = "#000";
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
      }
      // Reset line width for further drawing.
      ctx.lineWidth = 1;
    }

    function drawPieces() {
      try {
        ctx.font = "20px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (let i = 0; i < 24; i++) {
          if (!board[i]) continue;
          let tri = getTriangleCoordinates(i);
          let centerX = tri.x + tri.width / 2;
          let spacing = Math.min(tri.width, tri.height) / 2.2;
          for (let j = 0; j < board[i].count; j++) {
            let centerY = (i >= 12)
              ? tri.y + (j + 0.5) * spacing
              : tri.y + tri.height - (j + 0.5) * spacing;
            ctx.beginPath();
            ctx.arc(centerX, centerY, spacing * 0.8, 0, 2 * Math.PI);
            ctx.fillStyle = (board[i].owner === 'w') ? "#fff" : "#000";
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.stroke();
          }
          if (board[i].count > 5) {
            ctx.fillStyle = "red";
            ctx.fillText(board[i].count, centerX, tri.y + tri.height / 2);
          }
        }
      } catch (err) { logBug("drawPieces", err); }
    }
    function getTriangleCoordinates(idx) {
      let x, y, width = pointWidth, height;
      if (idx >= 12 && idx <= 23) {
        let p = idx + 1;
        x = boardMargin + (p - 13) * pointWidth;
        y = boardTop;
        height = boardHeight / 2;
        return { x, y, width, height, direction: "down" };
      } else if (idx >= 0 && idx <= 11) {
        let p = idx + 1;
        let pos = 12 - p;
        x = boardMargin + pos * pointWidth;
        y = boardTop + boardHeight / 2;
        height = boardHeight / 2;
        return { x, y, width, height, direction: "up" };
      }
      return null;
    }

    /* --- Move Logic & Bear Off Rules --- */
    // White moves upward (increasing index), Black moves downward.
    function canBearOff(color) {
      let inHome = true;
      for (let i = 0; i < 24; i++) {
        if (board[i] && board[i].owner === color) {
          if (color === 'w' && i < 18) inHome = false; // White home: indices 18–23 (points 19–24)
          if (color === 'b' && i > 5) inHome = false;  // Black home: indices 0–5 (points 1–6)
        }
      }
      if (bar[color] > 0) inHome = false;
      return inHome;
    }
    // getLegalMoves now includes bear off moves with overshoot rules.
    function getLegalMoves(pointIndex) {
      let moves = [];
      if (!board[pointIndex] || board[pointIndex].owner !== currentTurn) return moves;
      for (let die of currentDice) {
        let dest;
        if (currentTurn === 'w') {
          dest = pointIndex + die;
          if (dest > 23) {
            // Overshoot allowed only if this is the furthest advanced white checker.
            let minIndex = 24;
            for (let i = 18; i < 24; i++) {
              if (board[i] && board[i].owner === 'w') {
                minIndex = Math.min(minIndex, i);
              }
            }
            if (pointIndex === minIndex && canBearOff('w')) {
              moves.push({ from: pointIndex, to: 24, die, bearOff: true });
              continue;
            }
          } else {
            if (dest >= 0 && dest <= 23) {
              if (!board[dest]) moves.push({ from: pointIndex, to: dest, die });
              else if (board[dest].owner === currentTurn) moves.push({ from: pointIndex, to: dest, die });
              else if (board[dest].count === 1) moves.push({ from: pointIndex, to: dest, die, hit: true });
            }
          }
        } else {
          dest = pointIndex - die;
          if (dest < 0) {
            let maxIndex = -1;
            for (let i = 0; i < 6; i++) {
              if (board[i] && board[i].owner === 'b') {
                maxIndex = Math.max(maxIndex, i);
              }
            }
            if (pointIndex === maxIndex && canBearOff('b')) {
              moves.push({ from: pointIndex, to: -1, die, bearOff: true });
              continue;
            }
          } else {
            if (dest >= 0 && dest <= 23) {
              if (!board[dest]) moves.push({ from: pointIndex, to: dest, die });
              else if (board[dest].owner === currentTurn) moves.push({ from: pointIndex, to: dest, die });
              else if (board[dest].count === 1) moves.push({ from: pointIndex, to: dest, die, hit: true });
            }
          }
        }
      }
      return moves;
    }
    function getLegalMovesFromBar() {
      let moves = [];
      if (bar[currentTurn] <= 0) return moves;
      for (let die of currentDice) {
        let dest;
        if (currentTurn === 'w') {
          dest = die - 1; // white re-enters at points 1-6 (indices 0–5)
        } else {
          dest = 24 - die; // black re-enters at points 19-24 (indices 18–23)
        }
        if (dest < 0 || dest > 23) continue;
        if (!board[dest]) moves.push({ from: "bar", to: dest, die });
        else if (board[dest].owner === currentTurn) moves.push({ from: "bar", to: dest, die });
        else if (board[dest].count === 1) moves.push({ from: "bar", to: dest, die, hit: true });
      }
      return moves;
    }

    /* --- Making Moves --- */
    function makeMove(move) {
      try {
        if (move.from === "bar") {
          bar[currentTurn]--;
        } else {
          if (board[move.from]) {
            board[move.from].count--;
            if (board[move.from].count === 0) board[move.from] = null;
          } else { logBug("makeMove", "No checker at " + move.from); }
        }
        if (move.bearOff) {
          borneOff[currentTurn]++;
        } else {
          if (move.hit) {
            if (board[move.to] && board[move.to].owner !== currentTurn && board[move.to].count === 1) {
              bar[board[move.to].owner]++;
              board[move.to] = { owner: currentTurn, count: 1 };
            }
          } else {
            if (!board[move.to]) {
              board[move.to] = { owner: currentTurn, count: 1 };
            } else if (board[move.to].owner === currentTurn) {
              board[move.to].count++;
            }
          }
        }
        const idx = currentDice.indexOf(move.die);
        if (idx !== -1) currentDice.splice(idx, 1);
        selectedPoint = null;
        legalMoves = [];
      } catch (err) { logBug("makeMove", err); }
    }
    function checkGameOver() {
      if (borneOff['w'] >= 15) {
        gameState = "game_over";
        gameOverText.textContent = "Game Over: White wins!";
        showGameOver();
        return true;
      } else if (borneOff['b'] >= 15) {
        gameState = "game_over";
        gameOverText.textContent = "Game Over: Black wins!";
        showGameOver();
        return true;
      }
      return false;
    }

    /* --- Input Handling (Human) --- */
    boardCanvas.addEventListener("mousedown", (e) => {
      if (currentTurn !== playerColor) return;
      try {
        const rect = boardCanvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        let clicked = getPointFromCoordinates(mx, my);
        if (bar[currentTurn] > 0) {
          let reEntry = getLegalMovesFromBar();
          if (!reEntry.length) return;
          selectedPoint = "bar";
          legalMoves = reEntry;
          let move = reEntry.find(m => m.to === clicked);
          if (move) {
            redrawGame();
            setTimeout(() => {
              makeMove(move);
              redrawGame();
              if (currentDice.length > 0 && !hasLegalMoves()) {
                currentDice = [];
                showNoLegalMove();
                return;
              }
              if (currentDice.length === 0) { endTurn(); }
            }, humanDelay);
          }
          return;
        }
        if (clicked === null) return;
        if (selectedPoint === null) {
          if (board[clicked] && board[clicked].owner === currentTurn) {
            let moves = getLegalMoves(clicked);
            if (moves.length) {
              selectedPoint = clicked;
              legalMoves = moves;
            }
          }
        } else {
          let move = legalMoves.find(m => m.to === clicked);
          if (move) {
            selectedPoint = move.from;
            legalMoves = [move];
            redrawGame();
            setTimeout(() => {
              makeMove(move);
              redrawGame();
              if (currentDice.length > 0 && !hasLegalMoves()) {
                currentDice = [];
                showNoLegalMove();
                return;
              }
              if (currentDice.length === 0) { endTurn(); }
            }, humanDelay);
          } else { selectedPoint = null; legalMoves = []; }
        }
        redrawGame();
      } catch (err) { logBug("boardCanvas mousedown", err); }
    });
    function getPointFromCoordinates(x, y) {
      try {
        if (y < boardTop || y > boardTop + boardHeight) return null;
        let pt;
        if (y < boardTop + boardHeight / 2) {
          let pos = Math.floor((x - boardMargin) / pointWidth);
          pt = pos + 13;
        } else {
          let pos = Math.floor((x - boardMargin) / pointWidth);
          pt = 12 - pos;
        }
        return pt - 1;
      } catch (err) { logBug("getPointFromCoordinates", err); return null; }
    }
    function hasLegalMoves() {
      let moves = [];
      if (bar[currentTurn] > 0) moves = getLegalMovesFromBar();
      else {
        for (let i = 0; i < 24; i++) {
          if (board[i] && board[i].owner === currentTurn) {
            let m = getLegalMoves(i);
            if (m.length) moves = moves.concat(m);
          }
        }
      }
      return moves.length > 0;
    }
    function endTurn() {
      currentTurn = (currentTurn === 'w') ? 'b' : 'w';
      if (!checkGameOver()) {
        if (currentTurn === playerColor) {
          rollDiceBtn.style.display = "block";
          if (testingMode) customRollToggleBtn.style.display = "block";
        } else {
          rollDiceBtn.style.display = "none";
          if (testingMode) customRollToggleBtn.style.display = "none";
          aiTurn();
        }
      }
    }

    /* --- Show "No Legal Move" Overlay --- */
    function showNoLegalMove() {
      noLegalMoveOverlay.style.display = "flex";
      setTimeout(() => {
        noLegalMoveOverlay.style.display = "none";
        endTurn();
      }, 2000);
    }

    /* --- AI Turn --- */
    function aiTurn() {
      if (currentTurn === playerColor) return;
      aiThinking = true;
      let delay = getAIDelay();
      setTimeout(() => {
        if (currentDice.length === 0) {
          currentDice = rollDice();
          drawDiceOnCanvas();
        }
        if (!hasLegalMoves()) {
          showNoLegalMove();
          return;
        }
        let poss = [];
        if (bar[currentTurn] > 0) {
          poss = getLegalMovesFromBar();
        } else {
          for (let i = 0; i < 24; i++) {
            if (board[i] && board[i].owner === currentTurn) {
              let m = getLegalMoves(i);
              if (m.length) poss = poss.concat(m);
            }
          }
        }
        if (poss.length > 0) {
          let move = poss[Math.floor(Math.random() * poss.length)];
          makeMove(move);
          redrawGame();
          if (currentDice.length > 0 && !hasLegalMoves()) {
            currentDice = [];
            showNoLegalMove();
            return;
          }
          if (currentDice.length > 0) {
            setTimeout(aiTurn, delay);
          } else {
            aiThinking = false;
            currentTurn = (currentTurn === 'w') ? 'b' : 'w';
            if (currentTurn === playerColor) {
              rollDiceBtn.style.display = "block";
              if (testingMode) customRollToggleBtn.style.display = "block";
            } else {
              setTimeout(aiTurn, delay);
            }
          }
        } else {
          currentDice = [];
          showNoLegalMove();
        }
      }, delay);
    }

    /* --- Overlays & Menus --- */
    function hideAllScreens() {
      menuScreen.style.display = "none";
      instructionsScreen.style.display = "none";
      colorScreen.style.display = "none";
      difficultyScreen.style.display = "none";
      gameOverScreen.style.display = "none";
      customRollOverlay.style.display = "none";
      noLegalMoveOverlay.style.display = "none";
    }
    function showMenu() { hideAllScreens(); gameState = "menu"; menuScreen.style.display = "flex"; }
    function showInstructions() { hideAllScreens(); gameState = "instructions"; instructionsScreen.style.display = "flex"; }
    function showColorChoice() { hideAllScreens(); gameState = "color_choice"; colorScreen.style.display = "flex"; }
    function showDifficultyChoice() { hideAllScreens(); gameState = "difficulty_choice"; difficultyScreen.style.display = "flex"; }
    function startGame() {
      hideAllScreens();
      gameState = "playing";
      initBoard();
      redrawGame();
      if (currentTurn === playerColor) {
        rollDiceBtn.style.display = "block";
        if (testingMode) customRollToggleBtn.style.display = "block";
      } else {
        rollDiceBtn.style.display = "none";
        if (testingMode) customRollToggleBtn.style.display = "none";
        aiTurn();
      }
    }
    function showGameOver() { hideAllScreens(); gameState = "game_over"; gameOverScreen.style.display = "flex"; }

    document.getElementById("newGameBtn").onclick = () => { showColorChoice(); };
    document.getElementById("instructionsBtn").onclick = () => { showInstructions(); };
    document.getElementById("whiteSideBtn").onclick = () => { playerColor = "w"; showDifficultyChoice(); };
    document.getElementById("blackSideBtn").onclick = () => { playerColor = "b"; showDifficultyChoice(); };
    document.getElementById("easyBtn").onclick = () => { difficulty = "easy"; startGame(); };
    document.getElementById("mediumBtn").onclick = () => { difficulty = "medium"; startGame(); };
    document.getElementById("hardBtn").onclick = () => { difficulty = "hard"; startGame(); };
    document.getElementById("gameOverNewGameBtn").onclick = () => { showColorChoice(); };
    document.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      if (gameState === "color_choice") {
        if (key === "w") document.getElementById("whiteSideBtn").click();
        if (key === "b") document.getElementById("blackSideBtn").click();
      } else if (gameState === "difficulty_choice") {
        if (key === "e") document.getElementById("easyBtn").click();
        if (key === "m") document.getElementById("mediumBtn").click();
        if (key === "h") document.getElementById("hardBtn").click();
      } else if (["playing", "instructions", "game_over"].includes(gameState)) {
        if (key === "m") showMenu();
      }
    });

    /* --- Redraw & Main Loop --- */
    function redrawGame() {
      try {
        drawBoard();
        highlightLegalOptions();
        drawPieces();
        drawDiceOnCanvas();
        drawBarPieces();
        updateCustomRollVisibility();
      } catch (err) { logBug("redrawGame", err); }
    }
    function mainLoop() { if (gameState === "playing") redrawGame(); requestAnimationFrame(mainLoop); }
    window.addEventListener("load", () => { showMenu(); mainLoop(); });

    /* --- Bar Pieces Drawing --- */
    function drawBarPieces() {
      try {
        barCtx.clearRect(0, 0, barCanvas.width, barCanvas.height);
        barCtx.font = "16px sans-serif";
        barCtx.fillStyle = "#000";
        barCtx.fillText("Bar", barCanvas.width / 2, 20);
        const pieceRadius = 15, spacing = pieceRadius * 2.2;
        for (let j = 0; j < bar.w; j++) {
          let cx = barCanvas.width / 2, cy = 40 + j * spacing;
          barCtx.beginPath();
          barCtx.arc(cx, cy, pieceRadius, 0, 2 * Math.PI);
          barCtx.fillStyle = "#fff";
          barCtx.fill();
          barCtx.strokeStyle = "#000";
          barCtx.stroke();
        }
        for (let j = 0; j < bar.b; j++) {
          let cx = barCanvas.width / 2, cy = barCanvas.height - 40 - j * spacing;
          barCtx.beginPath();
          barCtx.arc(cx, cy, pieceRadius, 0, 2 * Math.PI);
          barCtx.fillStyle = "#000";
          barCtx.fill();
          barCtx.strokeStyle = "#000";
          barCtx.stroke();
        }
      } catch (err) { logBug("drawBarPieces", err); }
    }
  </script>
</body>
</html>
