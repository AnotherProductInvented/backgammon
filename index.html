<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Backgammon – Integrated Bear-Off & Animated Dice</title>
  <style>
    body {
      margin: 0; 
      padding: 0;
      background: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 { margin: 1rem 0 0.5rem; text-align: center; }
    .overlayScreen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      background: rgba(255,255,255,0.95);
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      z-index: 5;
    }
    /* Overlays */
    #noLegalMoveOverlay { font-size: 48px; color: red; }
    #customRollOverlay { font-size: 20px; }
    button { font-size: 18px; margin: 10px; padding: 10px 20px; cursor: pointer; }
    input { font-size: 18px; margin: 5px; padding: 5px; width: 50px; text-align: center; }
    /* Main container: 3 columns (Bar, Board, Dice) */
    #mainContainer {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      margin-top: 20px;
    }
    #barContainer { width: 150px; text-align: center; }
    /* The boardCanvas integrates bear-off zones:
         - Top zone for White bear-off (from y=20 to boardTop-20)
         - Main board from boardTop to boardTop+boardHeight
         - Bottom zone for Black bear-off (from boardTop+boardHeight+20 to HEIGHT-20)
    */
    #boardContainer { 
      position: relative; 
      width: 720px; 
      height: 800px; 
      background: #f5f5f5; 
      margin: 0 20px;
    }
    #diceContainer { width: 150px; text-align: center; }
    canvas {
      background: #fff;
      border: 2px solid #000;
      display: block;
      margin: 10px auto;
    }
    #logo { 
      position: fixed; 
      bottom: 10px; right: 10px; 
      max-width: 100px; 
      z-index: 2000; 
    }
  </style>
</head>
<body>
  <!-- Menus & Overlays -->
  <div id="menuScreen" class="overlayScreen" style="display: flex;">
    <h1>Backgammon</h1>
    <button id="newGameBtn">New Game</button>
    <button id="instructionsBtn">Instructions</button>
  </div>
  <div id="colorScreen" class="overlayScreen">
    <p>Choose Your Color:</p>
    <button id="whiteSideBtn">White [W]</button>
    <button id="blackSideBtn">Black [B]</button>
    <p>You can also press W or B.</p>
  </div>
  <div id="difficultyScreen" class="overlayScreen">
    <p>Select Difficulty:</p>
    <button id="easyBtn">Easy [E]</button>
    <button id="mediumBtn">Medium [M]</button>
    <button id="hardBtn">Hard [H]</button>
    <p>You can also press E, M, or H.</p>
  </div>
  <div id="instructionsScreen" class="overlayScreen">
    <h2>How to Play</h2>
    <p>
      Rolling the Dice – Each player rolls two dice (animated for effect) and moves their checkers based on the numbers rolled.<br>
      Moving Checkers – Checkers move toward your home board. You can split or combine dice values for movement.<br>
      Landing on a Point – You can land on an open point or one occupied by your checkers. Landing on a single opponent checker (a blot) sends it to the bar.<br>
      Re-entering from the Bar – If you have a checker on the bar, you must enter it before making other moves.<br>
      Bearing Off – Once all your checkers are in your home board, you can bear them off by rolling dice matching occupied points.<br>
      (White can bear off only if all white checkers are in points 19–24; Black only if all black checkers are in points 1–6.)<br>
      Winning – The first player to bear off all their checkers wins.<br>
      Press [M] to return to the main menu.
    </p>
  </div>
  <div id="gameOverScreen" class="overlayScreen">
    <h2 id="gameOverText"></h2>
    <button id="gameOverNewGameBtn">New Game</button>
    <p>Press [M] to return.</p>
  </div>
  <!-- "No Legal Move" Overlay -->
  <div id="noLegalMoveOverlay" class="overlayScreen">
    <h2>No Legal Move</h2>
  </div>
  <!-- Custom Roll Overlay (Testing Only) -->
  <div id="customRollOverlay" class="overlayScreen">
    <p>Enter Custom Dice Roll:</p>
    <input type="number" id="customDie1" min="1" max="6" value="1">
    <input type="number" id="customDie2" min="1" max="6" value="1">
    <button id="customRollBtn">Roll Custom</button>
  </div>

  <!-- Main Game Container: 3 Columns (Bar, Board, Dice) -->
  <div id="mainContainer">
    <!-- Bar Column -->
    <div id="barContainer">
      <h3>Bar</h3>
      <canvas id="barCanvas" width="150" height="200"></canvas>
    </div>
    <!-- Board Column (Integrated Bear-Off Zones) -->
    <div id="boardContainer">
      <canvas id="boardCanvas" width="720" height="800"></canvas>
    </div>
    <!-- Dice Column -->
    <div id="diceContainer">
      <button id="rollDiceBtn" style="display: none;">Roll Dice</button>
      <button id="customRollToggleBtn" style="display: none;">Custom Roll</button>
      <canvas id="diceCanvas" width="150" height="70"></canvas>
    </div>
  </div>
  <img id="logo" src="logo.png" alt="Logo">

  <script>
    /* =======================
       Utility & Bug Logging
    ========================== */
    let bugLogs = [];
    function logBug(loc, details) {
      const entry = { time: new Date().toISOString(), loc, details };
      bugLogs.push(entry);
      console.error("Bug:", entry);
    }
    window.onerror = (msg, src, line, col, err) =>
      logBug("Global", { msg, src, line, col, err });

    /* =======================
       Global Variables & Constants
    ========================== */
    const boardCanvas = document.getElementById("boardCanvas"),
          ctx = boardCanvas.getContext("2d"),
          diceCanvas = document.getElementById("diceCanvas"),
          diceCtx = diceCanvas.getContext("2d"),
          barCanvas = document.getElementById("barCanvas"),
          barCtx = barCanvas.getContext("2d");

    const menuScreen = document.getElementById("menuScreen"),
          instructionsScreen = document.getElementById("instructionsScreen"),
          colorScreen = document.getElementById("colorScreen"),
          difficultyScreen = document.getElementById("difficultyScreen"),
          gameOverScreen = document.getElementById("gameOverScreen"),
          gameOverText = document.getElementById("gameOverText"),
          rollDiceBtn = document.getElementById("rollDiceBtn"),
          noLegalMoveOverlay = document.getElementById("noLegalMoveOverlay"),
          customRollOverlay = document.getElementById("customRollOverlay"),
          customRollBtn = document.getElementById("customRollBtn"),
          customRollToggleBtn = document.getElementById("customRollToggleBtn");

    // Board dimensions: reserve top 130px for White's bear-off zone and bottom 80px for Black's.
    const WIDTH = 720, HEIGHT = 800,
          boardMargin = 20,
          boardTop = 130,
          boardHeight = 800 - boardTop - 80,  // main board area height
          boardWidth = WIDTH - 2*boardMargin,
          pointWidth = boardWidth/12;

    // Game state and variables
    let gameState = "menu", playerColor = null, difficulty = null,
        // White moves upward (points 1→24), Black moves downward (points 24→1)
        currentTurn = "w", selectedPoint = null, legalMoves = [],
        currentDice = [], aiThinking = false,
        borneOff = { w: 0, b: 0 },
        board = new Array(24).fill(null),
        bar = { w: 0, b: 0 };

    const humanDelay = 300;
    function getAIDelay() {
      return difficulty === "hard" ? 1800 : difficulty === "medium" ? 1500 : 1200;
    }

    // Testing mode: set to true to show custom roll controls
    const testingMode = true;

    /* =======================
       Dice Animation Function
    ========================== */
    function animateDice(finalDice, duration, callback) {
      let startTime = Date.now();
      let interval = setInterval(() => {
        let elapsed = Date.now() - startTime;
        if (elapsed < duration) {
          // Draw random dice values
          let randomDice = [Math.floor(Math.random()*6)+1, Math.floor(Math.random()*6)+1];
          currentDice = randomDice;
          drawDiceOnCanvas();
        } else {
          clearInterval(interval);
          currentDice = finalDice;
          drawDiceOnCanvas();
          if(callback) callback();
        }
      }, 100);
    }

    /* =======================
       Board & Bear-Off Zone Drawing
    ========================== */
    function drawBoard(){
      try {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        // Draw bear-off zones integrated in board:
        // Top zone for White's bear-off: from y=20 to boardTop-20
        ctx.fillStyle = "#e0e0e0";
        ctx.fillRect(0, 20, WIDTH, boardTop-20);
        ctx.strokeStyle = "blue";
        ctx.lineWidth = 3;
        ctx.strokeRect(boardMargin, 20, boardWidth, boardTop-40);
        ctx.font = "16px sans-serif";
        ctx.fillStyle = "blue";
        ctx.textAlign = "center";
        ctx.fillText("White Bear Off", boardMargin + boardWidth/2, 40);
        // Bottom zone for Black's bear-off: from boardTop+boardHeight+20 to HEIGHT-20
        ctx.fillStyle = "#e0e0e0";
        ctx.fillRect(0, boardTop+boardHeight+20, WIDTH, HEIGHT - (boardTop+boardHeight+20));
        ctx.strokeStyle = "blue";
        ctx.strokeRect(boardMargin, boardTop+boardHeight+20, boardWidth, HEIGHT - (boardTop+boardHeight+20) - 20);
        ctx.fillStyle = "blue";
        ctx.fillText("Black Bear Off", boardMargin + boardWidth/2, boardTop+boardHeight+40);
        // Draw main board area:
        ctx.fillStyle = "#f5f5f5";
        ctx.fillRect(0, boardTop, WIDTH, boardHeight);
        ctx.fillStyle = "#006400";
        ctx.fillRect(boardMargin, boardTop, boardWidth, boardHeight);
        // Draw top row triangles (points 13–24)
        for(let p=13; p<=24; p++){
          let idx = p-1;
          let x = boardMargin + (p-13)*pointWidth;
          let y = boardTop;
          let tri = { x, y, width: pointWidth, height: boardHeight/2, direction:"down" };
          let color = (p%2===0) ? "#deb887" : "#d2b48c";
          drawTriangle(tri.x, tri.y, tri.width, tri.height, tri.direction, color);
        }
        // Draw bottom row triangles (points 1–12)
        for(let p=1; p<=12; p++){
          let pos = 12 - p;
          let x = boardMargin + pos * pointWidth;
          let y = boardTop + boardHeight/2;
          let tri = { x, y, width: pointWidth, height: boardHeight/2, direction:"up" };
          let color = (p%2===0) ? "#deb887" : "#d2b48c";
          drawTriangle(tri.x, tri.y, tri.width, tri.height, tri.direction, color);
        }
        // Draw borne-off pieces in the bear-off zones:
        drawBearOffPieces();
        // Reset lineWidth
        ctx.lineWidth = 1;
      } catch(err){ logBug("drawBoard", err); }
    }
    function drawTriangle(x, y, width, height, direction, color){
      try {
        ctx.fillStyle = color;
        ctx.beginPath();
        if(direction==="up"){
          ctx.moveTo(x, y+height);
          ctx.lineTo(x+width/2, y);
          ctx.lineTo(x+width, y+height);
        } else {
          ctx.moveTo(x, y);
          ctx.lineTo(x+width/2, y+height);
          ctx.lineTo(x+width, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
      } catch(err){ logBug("drawTriangle", err); }
    }
    // Draw borne-off pieces in the integrated zones.
    function drawBearOffPieces(){
      const pieceRadius = 15, spacing = pieceRadius * 2.2;
      // White borne-off: drawn in the top bear-off zone (bottom edge of that zone)
      for(let i=0; i<borneOff.w; i++){
        let cx = boardMargin + 30 + i * spacing;
        let cy = boardTop - 30; // 30px above boardTop
        ctx.beginPath();
        ctx.arc(cx, cy, pieceRadius, 0, 2*Math.PI);
        ctx.fillStyle = "#fff";
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
      }
      // Black borne-off: drawn in the bottom bear-off zone (top edge of that zone)
      for(let i=0; i<borneOff.b; i++){
        let cx = boardMargin + 30 + i * spacing;
        let cy = boardTop + boardHeight + 50; // 50px below boardTop+boardHeight
        ctx.beginPath();
        ctx.arc(cx, cy, pieceRadius, 0, 2*Math.PI);
        ctx.fillStyle = "#000";
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
      }
    }
    function drawPieces(){
      try {
        ctx.font="20px sans-serif"; 
        ctx.textAlign="center"; 
        ctx.textBaseline="middle";
        for(let i=0;i<24;i++){
          if(!board[i]) continue;
          let tri = getTriangleCoordinates(i);
          let centerX = tri.x + tri.width/2;
          let spacing = Math.min(tri.width,tri.height)/2.2;
          for(let j=0;j<board[i].count;j++){
            let centerY = (i>=12)
              ? tri.y + (j+0.5)*spacing
              : tri.y + tri.height - (j+0.5)*spacing;
            ctx.beginPath();
            ctx.arc(centerX, centerY, spacing*0.8, 0, 2*Math.PI);
            ctx.fillStyle = (board[i].owner==='w') ? "#fff" : "#000";
            ctx.fill();
            ctx.strokeStyle="#000";
            ctx.stroke();
          }
          if(board[i].count>5){
            ctx.fillStyle="red";
            ctx.fillText(board[i].count, centerX, tri.y+tri.height/2);
          }
        }
      } catch(err){ logBug("drawPieces", err); }
    }
    function getTriangleCoordinates(idx){
      let x, y, width = pointWidth, height;
      if(idx>=12 && idx<=23){
        let p = idx+1;
        x = boardMargin + (p-13)*pointWidth;
        y = boardTop;
        height = boardHeight/2;
        return { x, y, width, height, direction:"down" };
      } else if(idx>=0 && idx<=11){
        let p = idx+1;
        let pos = 12-p;
        x = boardMargin + pos*pointWidth;
        y = boardTop + boardHeight/2;
        height = boardHeight/2;
        return { x, y, width, height, direction:"up" };
      }
      return null;
    }

    /* =======================
       Dice & Animation
    ========================== */
    function rollDice() {
      try {
        const d1 = Math.floor(Math.random()*6)+1,
              d2 = Math.floor(Math.random()*6)+1;
        return (d1===d2) ? [d1,d1,d1,d1] : [d1,d2];
      } catch(err){ logBug("rollDice", err); return []; }
    }
    function drawDiceOnCanvas() {
      diceCtx.clearRect(0,0,diceCanvas.width,diceCanvas.height);
      if(!currentDice.length) return;
      const diceToShow = currentDice.slice(0,2),
            diceSize = 60, spacing = 10;
      diceToShow.forEach((d,i)=> drawDieOnCanvas(diceCtx, i*(diceSize+spacing), 0, diceSize, d));
    }
    function drawDieOnCanvas(ctx, x, y, size, value) {
      ctx.fillStyle="#fff";
      ctx.fillRect(x,y,size,size);
      ctx.strokeStyle="#000";
      ctx.strokeRect(x,y,size,size);
      ctx.fillStyle="#000";
      const dotRadius = size/10, cx = x+size/2, cy = y+size/2;
      const positions = {
        tl: { x: x+size*0.25, y: y+size*0.25 },
        tr: { x: x+size*0.75, y: y+size*0.25 },
        mid: { x: cx, y: cy },
        bl: { x: x+size*0.25, y: y+size*0.75 },
        br: { x: x+size*0.75, y: y+size*0.75 },
        ml: { x: x+size*0.25, y: cy },
        mr: { x: x+size*0.75, y: cy }
      };
      function drawDot(pos){ ctx.beginPath(); ctx.arc(pos.x,pos.y,dotRadius,0,2*Math.PI); ctx.fill(); }
      switch(value){
        case 1: drawDot(positions.mid); break;
        case 2: drawDot(positions.tl); drawDot(positions.br); break;
        case 3: drawDot(positions.tl); drawDot(positions.mid); drawDot(positions.br); break;
        case 4: drawDot(positions.tl); drawDot(positions.tr); drawDot(positions.bl); drawDot(positions.br); break;
        case 5: drawDot(positions.tl); drawDot(positions.tr); drawDot(positions.mid); drawDot(positions.bl); drawDot(positions.br); break;
        case 6: drawDot(positions.tl); drawDot(positions.tr); drawDot(positions.ml); drawDot(positions.mr); drawDot(positions.bl); drawDot(positions.br); break;
      }
    }
    // Animate dice for a duration (in ms) before settling on the final roll.
    function animateDice(finalDice, duration, callback) {
      let startTime = Date.now();
      let interval = setInterval(() => {
        let elapsed = Date.now() - startTime;
        if (elapsed < duration) {
          let randomDice = [Math.floor(Math.random()*6)+1, Math.floor(Math.random()*6)+1];
          currentDice = randomDice;
          drawDiceOnCanvas();
        } else {
          clearInterval(interval);
          currentDice = finalDice;
          drawDiceOnCanvas();
          if(callback) callback();
        }
      }, 100);
    }

    /* =======================
       Move Logic & Bear-Off Rules
    ========================== */
    function canBearOff(color){
      let inHome = true;
      for(let i=0;i<24;i++){
        if(board[i] && board[i].owner===color){
          if(color==='w' && i < 18) inHome = false;  // White must be in points 19–24 (indices 18–23)
          if(color==='b' && i > 5) inHome = false;   // Black must be in points 1–6 (indices 0–5)
        }
      }
      if(bar[color] > 0) inHome = false;
      return inHome;
    }
    function getLegalMoves(pointIndex){
      let moves = [];
      if(!board[pointIndex] || board[pointIndex].owner!==currentTurn) return moves;
      for(let die of currentDice){
        let dest;
        if(currentTurn==='w'){
          dest = pointIndex + die;
          if(dest > 23){
            let minIndex = 24;
            for(let i=18;i<24;i++){
              if(board[i] && board[i].owner==='w'){
                minIndex = Math.min(minIndex, i);
              }
            }
            if(pointIndex === minIndex && canBearOff('w')){
              moves.push({from: pointIndex, to: 24, die, bearOff: true});
              continue;
            }
          } else {
            if(dest>=0 && dest<=23){
              if(!board[dest]) moves.push({from: pointIndex, to: dest, die});
              else if(board[dest].owner===currentTurn) moves.push({from: pointIndex, to: dest, die});
              else if(board[dest].count===1) moves.push({from: pointIndex, to: dest, die, hit: true});
            }
          }
        } else {
          dest = pointIndex - die;
          if(dest < 0){
            let maxIndex = -1;
            for(let i=0;i<6;i++){
              if(board[i] && board[i].owner==='b'){
                maxIndex = Math.max(maxIndex, i);
              }
            }
            if(pointIndex === maxIndex && canBearOff('b')){
              moves.push({from: pointIndex, to: -1, die, bearOff: true});
              continue;
            }
          } else {
            if(dest>=0 && dest<=23){
              if(!board[dest]) moves.push({from: pointIndex, to: dest, die});
              else if(board[dest].owner===currentTurn) moves.push({from: pointIndex, to: dest, die});
              else if(board[dest].count===1) moves.push({from: pointIndex, to: dest, die, hit: true});
            }
          }
        }
      }
      return moves;
    }
    function getLegalMovesFromBar(){
      let moves = [];
      if(bar[currentTurn] <= 0) return moves;
      for(let die of currentDice){
        let dest;
        if(currentTurn==='w'){
          dest = die - 1;
        } else {
          dest = 24 - die;
        }
        if(dest < 0 || dest > 23) continue;
        if(!board[dest]) moves.push({from:"bar", to: dest, die});
        else if(board[dest].owner===currentTurn) moves.push({from:"bar", to: dest, die});
        else if(board[dest].count===1) moves.push({from:"bar", to: dest, die, hit: true});
      }
      return moves;
    }
    function makeMove(move){
      try {
        if(move.from==="bar"){
          bar[currentTurn]--;
        } else {
          if(board[move.from]){
            board[move.from].count--;
            if(board[move.from].count===0) board[move.from]=null;
          } else { logBug("makeMove","No checker at " + move.from); }
        }
        if(move.bearOff){
          borneOff[currentTurn]++;
        } else {
          if(move.hit){
            if(board[move.to] && board[move.to].owner!==currentTurn && board[move.to].count===1){
              bar[board[move.to].owner]++;
              board[move.to] = { owner: currentTurn, count: 1 };
            }
          } else {
            if(!board[move.to]){
              board[move.to] = { owner: currentTurn, count: 1 };
            } else if(board[move.to].owner===currentTurn){
              board[move.to].count++;
            }
          }
        }
        const idx = currentDice.indexOf(move.die);
        if(idx!==-1) currentDice.splice(idx,1);
        selectedPoint = null;
        legalMoves = [];
      } catch(err){ logBug("makeMove",err); }
    }
    function checkGameOver(){
      if(borneOff['w']>=15){
        gameState="game_over";
        gameOverText.textContent = "Game Over: White wins!";
        showGameOver();
        return true;
      } else if(borneOff['b']>=15){
        gameState="game_over";
        gameOverText.textContent = "Game Over: Black wins!";
        showGameOver();
        return true;
      }
      return false;
    }

    /* =======================
       Human Input Handling
    ========================== */
    boardCanvas.addEventListener("mousedown", (e)=>{
      if(currentTurn !== playerColor) return;
      try {
        const rect = boardCanvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        let clicked = getPointFromCoordinates(mx, my);
        if(bar[currentTurn] > 0){
          let reEntry = getLegalMovesFromBar();
          if(!reEntry.length) return;
          selectedPoint = "bar"; legalMoves = reEntry;
          let move = reEntry.find(m=> m.to === clicked);
          if(move){
            redrawGame();
            setTimeout(()=>{
              makeMove(move);
              redrawGame();
              if(currentDice.length > 0 && !hasLegalMoves()){
                currentDice = [];
                showNoLegalMove();
                return;
              }
              if(currentDice.length===0){ endTurn(); }
            }, humanDelay);
          }
          return;
        }
        if(clicked === null) return;
        if(selectedPoint === null){
          if(board[clicked] && board[clicked].owner===currentTurn){
            let moves = getLegalMoves(clicked);
            if(moves.length){
              selectedPoint = clicked;
              legalMoves = moves;
            }
          }
        } else {
          let move = legalMoves.find(m=> m.to === clicked);
          if(move){
            selectedPoint = move.from;
            legalMoves = [move];
            redrawGame();
            setTimeout(()=>{
              makeMove(move);
              redrawGame();
              if(currentDice.length > 0 && !hasLegalMoves()){
                currentDice = [];
                showNoLegalMove();
                return;
              }
              if(currentDice.length===0){ endTurn(); }
            }, humanDelay);
          } else { selectedPoint = null; legalMoves = []; }
        }
        redrawGame();
      } catch(err){ logBug("boardCanvas mousedown",err); }
    });
    function getPointFromCoordinates(x,y){
      try {
        if(y < boardTop || y > boardTop+boardHeight) return null;
        let pt;
        if(y < boardTop+boardHeight/2){
          let pos = Math.floor((x-boardMargin)/pointWidth);
          pt = pos+13;
        } else {
          let pos = Math.floor((x-boardMargin)/pointWidth);
          pt = 12-pos;
        }
        return pt-1;
      } catch(err){ logBug("getPointFromCoordinates",err); return null; }
    }
    function hasLegalMoves(){
      let moves = [];
      if(bar[currentTurn] > 0){
        moves = getLegalMovesFromBar();
      } else {
        for(let i=0;i<24;i++){
          if(board[i] && board[i].owner===currentTurn){
            let m = getLegalMoves(i);
            if(m.length) moves = moves.concat(m);
          }
        }
      }
      return moves.length > 0;
    }
    function endTurn(){
      currentTurn = (currentTurn==='w') ? 'b' : 'w';
      if(!checkGameOver()){
        if(currentTurn===playerColor){
          rollDiceBtn.style.display = "block";
          if(testingMode) customRollToggleBtn.style.display = "block";
        } else {
          rollDiceBtn.style.display = "none";
          if(testingMode) customRollToggleBtn.style.display = "none";
          aiTurn();
        }
      }
    }

    /* =======================
       Overlays & Menus
    ========================== */
    function hideAllScreens(){
      menuScreen.style.display="none";
      instructionsScreen.style.display="none";
      colorScreen.style.display="none";
      difficultyScreen.style.display="none";
      gameOverScreen.style.display="none";
      customRollOverlay.style.display="none";
      noLegalMoveOverlay.style.display="none";
    }
    function showMenu(){ hideAllScreens(); gameState="menu"; menuScreen.style.display="flex"; }
    function showInstructions(){ hideAllScreens(); gameState="instructions"; instructionsScreen.style.display="flex"; }
    function showColorChoice(){ hideAllScreens(); gameState="color_choice"; colorScreen.style.display="flex"; }
    function showDifficultyChoice(){ hideAllScreens(); gameState="difficulty_choice"; difficultyScreen.style.display="flex"; }
    function showGameOver(){ hideAllScreens(); gameState="game_over"; gameOverScreen.style.display="flex"; }
    function startGame(){
      hideAllScreens();
      gameState="playing";
      initBoard();
      redrawGame();
      if(currentTurn===playerColor){
        rollDiceBtn.style.display = "block";
        if(testingMode) customRollToggleBtn.style.display = "block";
      } else {
        rollDiceBtn.style.display = "none";
        if(testingMode) customRollToggleBtn.style.display = "none";
        aiTurn();
      }
    }

    document.getElementById("newGameBtn").onclick = ()=> { showColorChoice(); };
    document.getElementById("instructionsBtn").onclick = ()=> { showInstructions(); };
    document.getElementById("whiteSideBtn").onclick = ()=> { playerColor="w"; showDifficultyChoice(); };
    document.getElementById("blackSideBtn").onclick = ()=> { playerColor="b"; showDifficultyChoice(); };
    document.getElementById("easyBtn").onclick = ()=> { difficulty="easy"; startGame(); };
    document.getElementById("mediumBtn").onclick = ()=> { difficulty="medium"; startGame(); };
    document.getElementById("hardBtn").onclick = ()=> { difficulty="hard"; startGame(); };
    document.getElementById("gameOverNewGameBtn").onclick = ()=> { showColorChoice(); };
    document.addEventListener("keydown",(e)=>{
      const key = e.key.toLowerCase();
      if(gameState==="color_choice"){
        if(key==="w") document.getElementById("whiteSideBtn").click();
        if(key==="b") document.getElementById("blackSideBtn").click();
      } else if(gameState==="difficulty_choice"){
        if(key==="e") document.getElementById("easyBtn").click();
        if(key==="m") document.getElementById("mediumBtn").click();
        if(key==="h") document.getElementById("hardBtn").click();
      } else if(["playing","instructions","game_over"].includes(gameState)){
        if(key==="m") showMenu();
      }
    });

    /* =======================
       Redraw & Main Loop
    ========================== */
    function redrawGame(){
      try {
        drawBoard();
        highlightLegalOptions();
        drawPieces();
        drawDiceOnCanvas();
        drawBarPieces();
        updateCustomRollVisibility();
      } catch(err){ logBug("redrawGame",err); }
    }
    function mainLoop(){ if(gameState==="playing") redrawGame(); requestAnimationFrame(mainLoop); }
    window.addEventListener("load", ()=> { showMenu(); mainLoop(); });

    /* =======================
       Bar Pieces Drawing
    ========================== */
    function drawBarPieces(){
      try {
        barCtx.clearRect(0,0,barCanvas.width,barCanvas.height);
        barCtx.font = "16px sans-serif";
        barCtx.fillStyle = "#000";
        barCtx.fillText("Bar", barCanvas.width/2,20);
        const pieceRadius = 15, spacing = pieceRadius * 2.2;
        for(let j=0;j<bar.w;j++){
          let cx = barCanvas.width/2, cy = 40+j*spacing;
          barCtx.beginPath();
          barCtx.arc(cx,cy,pieceRadius,0,2*Math.PI);
          barCtx.fillStyle = "#fff"; 
          barCtx.fill();
          barCtx.strokeStyle = "#000"; 
          barCtx.stroke();
        }
        for(let j=0;j<bar.b;j++){
          let cx = barCanvas.width/2, cy = barCanvas.height-40-j*spacing;
          barCtx.beginPath();
          barCtx.arc(cx,cy,pieceRadius,0,2*Math.PI);
          barCtx.fillStyle = "#000"; 
          barCtx.fill();
          barCtx.strokeStyle = "#000"; 
          barCtx.stroke();
        }
      } catch(err){ logBug("drawBarPieces",err); }
    }

    /* =======================
       Highlight Legal Moves
    ========================== */
    function highlightLegalOptions(){
      if(selectedPoint !== null){
        let selCoords = getTriangleCoordinates(selectedPoint);
        if(selCoords){
          ctx.fillStyle = "rgba(0,255,255,0.5)";
          ctx.fillRect(selCoords.x, selCoords.y, selCoords.width, selCoords.height);
        }
        legalMoves.forEach(move=>{
          if(!move.bearOff){
            let destCoords = getTriangleCoordinates(move.to);
            if(destCoords){
              ctx.fillStyle = "rgba(255,255,0,0.5)";
              ctx.fillRect(destCoords.x, destCoords.y, destCoords.width, destCoords.height);
            }
          }
        });
      }
    }

    /* =======================
       AI Turn
    ========================== */
    function aiTurn(){
      if(currentTurn===playerColor) return;
      aiThinking = true;
      let delay = getAIDelay();
      setTimeout(()=>{
        if(currentDice.length===0){
          // Animate dice roll for 1 second
          animateDice(rollDice(), 1000, ()=>{});
          // Wait a little after animation
          setTimeout(()=>{}, 1100);
        }
        if(!hasLegalMoves()){
          showNoLegalMove();
          return;
        }
        let poss = [];
        if(bar[currentTurn] > 0){
          poss = getLegalMovesFromBar();
        } else {
          for(let i=0;i<24;i++){
            if(board[i] && board[i].owner===currentTurn){
              let m = getLegalMoves(i);
              if(m.length) poss = poss.concat(m);
            }
          }
        }
        if(poss.length > 0){
          let move = poss[Math.floor(Math.random() * poss.length)];
          makeMove(move);
          redrawGame();
          if(currentDice.length > 0 && !hasLegalMoves()){
            currentDice = [];
            showNoLegalMove();
            return;
          }
          if(currentDice.length > 0){
            setTimeout(aiTurn, delay);
          } else {
            aiThinking = false;
            currentTurn = (currentTurn==='w')?'b':'w';
            if(currentTurn===playerColor){
              rollDiceBtn.style.display = "block";
              if(testingMode) customRollToggleBtn.style.display = "block";
            } else {
              setTimeout(aiTurn, delay);
            }
          }
        } else {
          currentDice = [];
          showNoLegalMove();
        }
      }, delay);
    }

    /* =======================
       Show "No Legal Move" Overlay
    ========================== */
    function showNoLegalMove(){
      noLegalMoveOverlay.style.display = "flex";
      setTimeout(()=>{
        noLegalMoveOverlay.style.display = "none";
        endTurn();
      },2000);
    }

    /* =======================
       Update Custom Roll Visibility
    ========================== */
    function updateCustomRollVisibility(){
      if(testingMode){
        if(currentTurn===playerColor){
          customRollToggleBtn.style.display = "block";
        } else {
          customRollToggleBtn.style.display = "none";
        }
      }
    }
  </script>
</body>
</html>
